{"posts":[{"title":"动态规划","text":"背包问题01 背包01 背包本身是一个子集问题，有 n 个物品，每个物品都可以选择或者不选择，那这是一颗深度为 n 的二叉树，这是背包问题的暴力解法，穷举每一种组合，时间复杂度为 o(2^n)。 要注意背包问题的特点： 一般背包问题都是只有一个维度的限制，这里是背包的重量 W。 一般只求一个值，这里是价值 V。 1234567891011for(int i=0;i&lt;n;++i){ for(int j=w[i];j&lt;=W;++j){ dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]); }}//使用滚动数组优化for(int i=0;i&lt;n;++i){ for(int j=W;j&gt;=w[i];--j){//倒序是因为避免覆盖 dp[i-1][j] dp[j]=max(dp[j],dp[j-w[i]]+v[i]); }} 时间复杂度 O(NW)。 完全背包完全背包可以看作成 01 背包，我们可以把同种类型的没意见物品看作单独一个物品，这就是一个 01 背包。 1234567891011121314151617181920for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=W,++j){ for(int k=0;k*w[i]&lt;=j;++k){ dp[i][j]=max(dp[i][j],dp[i][j-k*w[i]]+k*v[i]); } }}//这样会存在重复的计算，比如 dp[i][j] 下选择 k 件物品，等同于 dp[i][j-w[i]] 选择 k-1 件物品。for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=W;++j){ dp[i][j]=d[i-1][j]; if(j&gt;=w[i]) dp[i][j]=max(dp[i][j],dp[i][j-w[i]] + v[i]); }}//使用滚动数组优化for(int i=0;i&lt;n;++i){ for(int j=w[i];j&lt;=W;++j){//顺序是因为需要使用 dp[i][j] 而不是 dp[i-1][j] dp[j]=max(dp[j],dp[j-w[i]]+v[i]); }} 多重部分和问题这个我觉得是多重背包的简单版本，它们的原始的推导公式几乎一样，但是因为求值比较简单，因为可以化简为类似完全背包的解法。 12345678910111213141516171819202122for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=K;++j){ for(int k=0;k*a[i]&lt;=j&amp;&amp;k&lt;=m[i];++k){ dp[i][j]|=dp[i-1][j-k*a[i]]; } }}//如果只是求 bool 结果的话，这样 dp 会有浪费，同样的复杂度可以存储更多的信息。//dp[i][j]: 表示使用第 i 种数字的时候，在和为 j 的情况下，最多可以剩余多少个该种数字。memset(dp,-1,sizeof(dp)); //memset 只可以填充 0 和 -1。for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=K;++j){ if(dp[j]&gt;=0){ dp[j]=m[i];//如果前 i - 1 种数字能满足和 j，则最多可以剩余 m[i] 个。 }else if(j&lt;a[i]||dp[j-a[i]]&lt;0){ dp[j]=-1; }else{ dp[j]=dp[j-a[i]]-1; } }}return dp[n][K]&gt;=0; 计数DP划分数有 n 个完全相同的物品，将它们分成不超过 m 组，求划分方法数摸 M 的余数。限制条件： 1&lt;=m&lt;=n&lt;=1000 2&lt;=M&lt;=10000; 递推公式： dp[i][j]: 表示 j 的 i 划分。dp[i][j]=dp[i][j-i]+dp[i-1][j]; 123456789101112131415int n,m;int dp[MAX_M+1][MAX_N+1];int solve(){ dp[0][0]=1; for(int i=1;i&lt;=m;++i){ for(int j=0;j&lt;=n;++j){ if(j&gt;=i){ dp[i][j]=dp[i][j-i] + dp[i-1][j]; }else{ dp[i][j]=dp[i-1][j]; } } } return dp[m][n];} 多重集的组合数有 n 种不同类型的物品，第 i 种物品有 a[i] 个，不同种类的物品可以相互区分，但是同种类型的物品无法区分，从这些物品中恰好取 m 个，有多少种取法？求出方案数模 M 的余数。 限制条件 1&lt;=n&lt;=1000; 1&lt;=m&lt;=1000; 1&lt;=a[i]&lt;=1000; 1&lt;=M&lt;=10000; 分析： 和划分数不一样，这题目是求只拿一组的情况下有多少种方法。 ps: 如果当当 n 个不同的物品中取出 M 个，则单纯是一个组合问题， dp[i][j]: 表示前 i 种物品，恰好取 j 件一共有多少种取法。那么如果第 i 种物品我想拿 k 件，那么方案数是前 i-1种物品中取出 j-k 件的方案数，因此：右边展开后，变形 所以：这样就可以在时间复杂度 o(nm) 内解决问题 1234567891011121314151617181920int n, m;int a[MAX_N];int dp[MAX_N][MAX_M];int solve(){ //初始化，前 i 个物品只取 0 个都是只有一个方案。 for(int i=0;i&lt;=n;++i){ dp[i][0]=1; } for(int i=0;i&lt;n;++i){ for(int j=1;j&lt;=m;++j){ if(j-1-a[i]&gt;=0){ dp[i+1][j]=(dp[i+1][j-1] + dp[i][j] - dp[i][j-1-a[i]] + M) % M; }else{ dp[i+1][j]=(dp[i+1][j-1] + dp[i][j]) % M;//如果没有数量 a[i] 限制的话，是不是就是完全背包的公式。 } } } return dp[n][m];} 参考资料《背包九讲》 《挑战程序设计竞赛》 《leetcode》 《oi-wiki》","link":"/blog/2024/02/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"贪心","text":"区间问题区间调度问题这种问题常常出现再工作或者会议安排上，其实就是求不相交区间数最大。 例题：参与尽量多的工作​ 有 n 项工作，每项工作分别再时间 si 开始，在时间 ti结束，对于每项工作，你都可以选择参与与否，但是如果选择参与，就必须完成该项工作，并且该工作时间段内不能参与任何其他工作。你的目标是参与尽量多的工作，返回该最大值。 限制条件： 1&lt;=N&lt;=100000; 1&lt;=si&lt;=ti&lt;=1e9; 例子： 输入：n=5; s={1,2,4,6,8}; t={3,5,7,9,0} 输出：3 （选取 1、3、5） 参考思路： 一般我们容易想到下面几个思路： 优先选择最早开始的：很明显会错误，最早开始也可以最迟结束，这样只能选择一个工作 优先选择最早结束的：是正确的，优先做尽量早结束的 优先选择用时最少的：一个用时很短的工作 C，可以连接两个本不相交的工作 A、B，这样本来可以选择 2 个变成了只能选择一个 优先选择最少重叠的：反例如下，第二行中间任务的重叠数最少，但如果优先选择此任务，最多只能完成 3 项，而实际全部选择第三行的任务，可以完成 4 项。 ———————— ———————————— ———————————————— 123456789101112131415161718//区间调度问题typedef pair&lt;int,int&gt; pi;pi itv[MAX_N];int solve(int n, vector&lt;int&gt; s, vector&lt;int&gt; t){ for(int i=0;i&lt;n;++i){ itv[i].second=s[i]; itv[i].first=t[i];//结束时间作 first } sort(itv.begin(),itv.end()); int ans=0; for(int i=0,t=0;i&lt;n;++i){ if(itv[i].second&gt;t){ ans++; t=itv[i].first; } } return ans;} 区间覆盖问题数轴上有 n 个闭区间 [ai,bi]，选择尽量少的区间，覆盖一条指定线段 [s,t]。突破口仍然是区间包含和区间排序，不过需要一次预处理。 每个区间在 [s,t] 外面的部分都应该切掉，因为它们是多余的。 预处理后，在相互包含的情况下，小区间显然是不应该考虑的。 把各个区间按照 ai 从小到大排序，如果第一个区间的起点不是 s，那么无解；否则选择起点为 s 的区间里面最长的一个，更新 s 为刚刚选择区间的 bi。 重复第一步，直到 s&gt;=t，或者区间已经被用完。 例题：leetcode 1024 视频拼接​ 你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。甚至可以对这些片段自由地再剪辑：例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。 123456789101112131415161718192021222324252627class Solution { typedef pair&lt;int,int&gt; pi;public: int videoStitching(vector&lt;vector&lt;int&gt;&gt;&amp; clips, int time) { vector&lt;pi&gt; ps; for(vector&lt;int&gt; c : clips){ ps.push_back({max(0,c[0]),min(time,c[1])}); } int n=ps.size(); //区间按照坐标开始时间从小到达排序 sort(ps.begin(),ps.end()); int ans=0,pre=0; //判断条件别漏了 pre &lt; time for(int i=0;i&lt;n&amp;&amp;pre&lt;time;++i){ //如果没有区间能覆盖当前的最左边，则返回-1 if(ps[i].first&gt;pre) return -1; int j=i; int t=ps[i].second; //所有能覆盖最左边的区间中选择最长的一个 while(i+1&lt;n&amp;&amp;ps[i+1].first&lt;=pre) t=max(t,ps[++i].second); pre=t;// 更新需要覆盖的最左边时间 ans++; } return pre &gt;=time ? ans : -1; }}; 区间问题（尤其覆盖问题）一定要注意： 区间的边界是否可以交接，要小心处理 s[i].end 和 s[i+1].start。 区间覆盖要记得 [s,t] 是否已经覆盖完，多余的区间要舍弃。 区间覆盖要记得区间是否已经使用完，最后要判断当前覆盖的最大值是否 &gt;= t。 45. 跳跃游戏 II 区间选点问题数轴上有 n 个闭区间 [ai,bi]。取尽量少的点，使得覆盖每个区间内至少有一个点。 和上面一样先考虑区间包含的情况，如果小区间被满足了，大区间一定被满足，所以在相互包含的情况下，大区间不应该考虑。 先按照 b 从小到大排序（b 相同 a 从大到小排序）。 取第一个区间的最后一个点，然后 ai 小于等于该点的区间都被跳过 ，直到 ai 大于刚刚选取的点，重复上一步。 例题：leetcode 452. 用最少数量的箭引爆气球​ 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart和 xend之间的气球。你不知道气球的确切y坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进，返回引爆所有气球所必须射出的 最小 弓箭数 。 1234567891011121314151617181920class Solution {public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { sort(points.begin(),points.end(), [](const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b){ // 按照 end 从小到大排序，如果 end 相同，start 大的排前面 //这样区间包含的时候小区间一定排在前面 return a[1]==b[1]?a[0]&gt;b[0]:a[1]&lt;b[1]; }); int n=points.size(); int ans=1,t=points[0][1]; for(int i=1;i&lt;n;++i){ if(points[i][0]&gt;t){ ans++; t=points[i][1]; } } return ans; }}; 区间最大重叠数问题我个人觉得这个应该不算贪心问题，更像一个单纯的模拟题，但是有时候我容易把它跟上面几个区间问题搞混了，因此在这里也记录一下。该问题就是求整个区间内最大的重叠数，打个比方就是一个大盘子里面放了好多饼，这些饼会相互部分重叠，也可能不重叠，求最厚的地方是多少。 例题：leetcode 253 会议室 II给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量。 思路分析：最早开始的会议肯定需要 1 个会议室，如果第 2 早开始的会议在前 1 个会议结束前开始，那么会议室 +1，否则使用空闲的。那么后面每个会议开始的时候都可以查看前面是否有空闲的会议室。我们可以使用计数来模拟上面的行为，我们把所有开始和结束的时间排序，碰到开始时间会议室 +1，碰到结束时间会议室 -1（这和后面开始的 +1 抵消，相当于使用空闲）。计数过程中的最大值，就是所需的最少会议室。也可以使用小根堆来模拟，那样模拟行为会更加明显。 12345678910111213141516171819class Solution { typedef pair&lt;int,int&gt; pi;public: int minMeetingRooms(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;pi&gt; times; for(vector&lt;int&gt;&amp; t : intervals){ times.push_back({t[0],1});// 1 表示开始 times.push_back({t[1],0});//如果某个结束时间和开始相同，结束排前面。 } sort(times.begin(),times.end()); int ans=0,cnt=0; for(auto &amp;t : times){ if(t.second) cnt++; else cnt--; ans=max(ans,cnt); } return ans; }}; 其他例题例题：POJ 3069 Saruman’s Army​ 直线上有 n 个点，坐标为 xi，选择若干个点添加标记，每个标记的点的覆盖范围是 R，要求所有点都能被标记点覆盖。求满足上述条件情况下，选择尽量少的点添加标记。 思路分析：我们从最左边的点开始考虑，这个点向右距离为 R 的范围内必须要有点（包括它自身）带有标记。哪给那个点带标记比较好呢？从贪心的角度考虑，最右的点是最好。因此我们从左边开始，选择其右边 R 范围内最远的点作为标记点，然把标记点右边距离其大于 R 的第一个点，作为新的最左边的点，依次类推。 1234567891011121314151617181920212223242526272829303132# include&lt;cstdio&gt;# include&lt;string&gt;# include&lt;algorithm&gt;using namespace std;int r,n,x[1010];// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif while(true){ scanf(\"%d %d\",&amp;r,&amp;n); if(r==-1&amp;&amp;n==-1) break; for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;x[i]); sort(x,x+n); int ans=0; for(int i=0;i&lt;n;++i){ int s=x[i]; int j=i; while(j+1&lt;n&amp;&amp;s+r&gt;=x[j+1]) ++j; int t=x[j]; while(j+1&lt;n&amp;&amp;t+r&gt;=x[j+1]) ++j; i=j; ans++; } printf(\"%d\\n\",ans); } return 0;} 字典序问题例题：note “POJ 3617 Best Cow Line​ 给定一个长度为 N 的字符串 S，要构造一个长度同样为 N 的字符 T，T 初始为空，你可以反复进行以下任意操作： 从 S 的头部删除一个字符，放到 T 的尾部。 从 S 的尾部删除一个字符，放到 T 的尾部 目标：T 字典序尽量小。 限制：1&lt;=N&lt;=1000 思路分析：从字典序的性质来看，无论 T 的末尾有多大，只要前面够小就行，因此我们可以使用下面的贪心算法：我们不断从 S 的开始和末尾取较小的一个。如果它们相等呢？因为我们贪心地想尽量早用到较小的字母，所以我们需要比较下一个，如果还相等，则下下一个，直到有一边较小的，那么就取较小的那一边的第一个。 因此我们可以这样设计算法： 我们可以把 S 反转后得到一个新的字符串 S’。 比较 S 和 S’ 的大小，如果 S 较小，则删除 S 的第一个字母添加到 T 的末尾；反之，则删除 S’ 的第一个字母添加到 T 的末尾。 依次类推直到 T 的长度等于原来字符串的长度。 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;const int MAX_N=2010;int N;char s[MAX_N];// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d\",&amp;N); for(int i =0;i&lt;N;++i){ scanf(\" %c\",&amp;s[i]); } int a=0; int b=N-1; int cnt=0; while(a&lt;=b){ bool left=true; for(int i=0;i+a&lt;=b-i;++i){ if(s[a+i]==s[b-i]) continue; left=s[a+i]&lt;s[b-i]; break; } if(left) putchar(s[a++]); else putchar(s[b--]); if(++cnt==80){ putchar('\\n'); cnt=0; } } if(cnt&lt;80) putchar('\\n'); return 0;} 哈夫曼编码问题哈夫曼编码的两个关键： 前缀码树：每个编码都是叶子路径编码，只有叶子才是最终的编码。 总价值最小的前缀码树：价值最小的两个节点最为兄弟节点，并且是深度最大的节点。 例题：POJ 3253 Fence Repair​ 有一块木板要切割成 块，每块的长度为 ,木板的初始长度为恰好是 的总和。每次切割的开销是这块木板的长度，求最小的切割开销。​ 例如长度为 21 木板需要切割成 5，8，8，则先把 21 切割成 8 和 13，开销是 21，再把 13 切割成 5 和 8，开销是 13，因此总开销是 34。 思路分析：把切割的过程看成一颗二叉树，根节点就是初始木板，需要最终切割的木板就是叶子，每次切割的开销为当前节点的长度，因此总的开销就是各个叶子节点木板的长度*其深度的和，因此我们就是要找一个让上面和最小的树，这不就和哈夫曼编码如何构造一颗最优编码树一样么？ 1234567891011121314151617181920212223242526272829303132333435363738394041# include&lt;cstdio&gt;# include&lt;string&gt;using namespace std;typedef long long LL;const int N=20010;int n,len[N];LL solve(){ LL ans=0; while(n&gt;1){ int mi1=0,mi2=1; if(len[mi1]&gt;len[mi2]) swap(mi1,mi2); for(int i=2;i&lt;n;++i){ if(len[i]&lt;=len[mi1]){ mi2=mi1; mi1=i; }else if(len[i]&lt;len[mi2]) mi2=i; } int t=len[mi1] + len[mi2]; ans+=t; if(mi1==n-1) swap(mi1,mi2); len[mi1]=t; len[mi2]=len[n-1]; --n; } return ans;}// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;len[i]); LL ans=solve(); printf(\"%lld\\n\",ans); return 0;} 邻项交换法例题：POJ 3045 Cow Acrobats​ N 头牛叠罗汉，每头牛都有一个体重值 wi 和一个理论值 si，一头牛叠罗汉时候承受的风险等于其上面所有牛的体重之和（不包括自己）减去自身的力量值。给出每头牛的 wi 和 si，求如何安排叠罗汉的顺序，让所有牛中最大的风险系数最小。 思路分析：我们假设存在两头相邻的牛 和 ，这两头牛是否交换顺序不会影响它们上面和它们下面的牛的风险系数，它们只会影响它们本身。设 T 是它们上面所有牛的重量，它们不交换顺序和交换顺序的最大风险系数分别是是： 和 我们把 T 去掉就有： 和 假如是 i 排在前面更优，那么前面的公式就会更小，因此我们可以根据这个来排序，然后上到下计算每头牛的风险系数，最大值就是答案。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt; #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;using namespace std;const int N=50010;int n;struct cow{ int s,w;}cows[N];//排序对比int cmp (const cow &amp;a, const cow&amp; b){ return max(a.w-b.s,-a.s) &lt; max(b.w-a.s,-b.s);}//贪心 邻项交换法// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;++i){ scanf(\"%d %d\",&amp;cows[i].w,&amp;cows[i].s); } sort(cows,cows+n,cmp); int ans=-1e9,sw=0; for(int i=0;i&lt;n;++i){ int risk=sw-cows[i].s; sw+=cows[i].w; ans=max(ans,risk); } printf(\"%d\\n\",ans); return 0;} P1080 NOIP2012 国王游戏 后悔法思路就是无论当前是否是最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍去掉这个选项，否则，正式接受。如此往复。 例题：leetcode 871 最低加油次数​ 汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。沿途有 n 个加油站， 表示第 i 个加油站距离出发点 x 英里，可以加 f 升汽油。汽车最初的油量是 startFuel，每行驶 1 英里消耗 1 升汽油，可以认为油箱的容量是无限的，求到达终点所需加油的最小次数，如果不能到达终点则返回 -1。??? note “思路分析”​ 由于是求最小的加油次数，因此先考虑不加油，如果能一直开到终点则答案为 0 ，反之如果我们在到达某个加油站前就已经用光了汽油，那么我们可以“后悔”没加油，从已经路过的加油站中选择加油量最大的加，如果还不够则继续选择次大的加，直到总油量能到达下一站。然后我们再按照前面的后悔法一直开，等到没油的时候再后悔。如此往复，直到终点。但是如果中间出现即使把前面路过的加油站的油全加了也无法到达下一站，则返回 -1。 其实这题也是区间覆盖问题，区间左边是加油站，右边是加油站 + 提供的油量，使用最小的区间覆盖开始到目的地。后悔法是一种处理问题的技巧，它有时会用来解决区间覆盖问题，但不是只解决此类问题。 12345678910111213141516171819202122class Solution { typedef long long LL;public: int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) { stations.push_back({target,0}); int n=stations.size(); LL s=startFuel; priority_queue&lt;int&gt; pq; int ans=0; for(int i=0;i&lt;n;++i){ while(s&lt;stations[i][0]&amp;&amp;pq.size()) { s+=pq.top(); pq.pop(); ans++; } if(s&lt;stations[i][0]) return -1; pq.push(stations[i][1]); } return ans; }}; USACO09OPEN 工作调度 Work Scheduling P1209 [USACO1.3]修理牛棚 Barn Repair leetcode 630. 课程表 III 参考资料《算法竞赛入门经典 第2版》 《挑战程序设计竞赛》 《leetcode》 《oi-wiki》","link":"/blog/2024/02/05/greedy/"},{"title":"二分","text":"查找值这是二分搜索最简单的用法，在有序的数组中查找某个值是否存在或者最接近某个值的值。 C++ STL 实现了二分查找值的算法，可以直接使用 123456789101112131415161718192021222324//返回第一个大于或者等于 x 的下标，如果不存在则返回 nint i=lower_bound(a,a+n,x) - a;//返回第一个大于或者等于 x 的迭代器，如果不存在则返回尾迭代器。auto it=lower_bound(a.begin(),a.end(),x);//返回第一个大于 x 的下标，如果不存在则返回 nint i=upper_bound(a,a+n,x) - a;//返回第一个大于或者等于 x 的迭代器，如果不存在则返回尾迭代器。auto it=upper_bound(a.begin(),a.end(),x);//注意： 如果是 set 和 map 这种关联式容器，使用上面的两个方法的时间复杂度是 O(n)，需要使用容器自带的方法，时间复杂度为 O(logn)。auto it=s.lower_bound(x);//快速找出有序数组 a 中 x 的数量。int cnt=upper_bound(a,a+n,x) - lower_bound(a,a+n,x);int cnt=upper_bound(a.begin(),a.end(),x) - lower_bound(a.begin(),a.end(),x);//有序数组 a 中 小于 x 的数量int cnt=lower_bound(a,a+n,x) - a;int cnt=lower_bound(a.begin(),a.end(),x) - a.begin();//有序数组 a 中 小于等于 x 的数量int cnt=upper_bound(a,a+n,x) - a;int cnt=upper_bound(a.begin(),a.end(),x) - a.begin(); 假定判断假定判断就是先假定一个解并且判断是否可行，在二分中使用也是非常的频繁，例如求解最大化或者最小化问题。 例题：POJ 1064 Cable master 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;const int N=10010;int n,k;double L[N];int calc(double len){ int res=0; for(int i=0;i&lt;n;++i) res+=(int)(L[i]/len); return res;}//标签：二分 求最大值 实数二分// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d\",&amp;n,&amp;k); for(int i=0;i&lt;n;++i){ scanf(\"%lf\",&amp;L[i]); } double l=0,r=100010; //100 次循环精度可以达到 10^-30，基本上是没有问题的 for(int i=0;i&lt;100;i++){ double md=(l+r)/2; if(calc(md)&gt;=k) l=md; else r=md; } printf(\"%.2f\\n\",floor(r*100)/100); return 0;} 最大化最小值例题：POJ 2456 Aggressive cows 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt; #include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N=100010;int n, c,x[N];bool check(int k,int cnt){ cnt--; for(int i=1,j=0;i&lt;n&amp;&amp;cnt;i++){ if(x[i]-x[j]&gt;=k){ j=i; cnt--; } } return cnt==0;}//标签：二分 最大值最小// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d\",&amp;n,&amp;c); for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;x[i]); sort(x,x+n); int l=0,r=x[n-1]-x[0]; while(l&lt;=r){ int md=l+(r-l)/2; if(check(md,c)) l=md+1; else r=md-1; } printf(\"%d\\n\",r);} 最大化最小值或者最小化最大值 经常也会带有一定的贪心算法在里面，通常借助排序或者优先队列来建立判断条件。 最大化平均值例题：有 n 个物品的重量和价值分别是 wi 和 vi。从中选出 k 个物品使得单位重量的价值最大。 限制条件： 1&lt;=k&lt;=n&lt;1000；1&lt;=wi,vi&lt;=1000000 样例： 输入：n=3；k=2；(w,v)={(2,2),(5,3),(2,1)} 输出：0.75 (选择 0 号和 2 号物品，(2+1)/(2+2)=0.75) 解题思路： 一般最先想到的方法是按照单位价值进行排序，从大到小贪心地进行选择，但是这种方法对于上面的例子的结果是 0.714，所以这种方式不可行。 我们可以使用二分解决这个问题，假定判断条件： 可以通过选择使得单位价值不小于那么原问题就变成了求满足 C(x) 的最大的 x。假设我们选择的集合是 s，因此它们的单位价值是： 把上面不等式进行变形： 因此可以对的值进行排序，然后贪心地进行选取： 从大到小前个和不小于 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;using namespace std;const int MAX_N = 10010;int n, k;int w[MAX_N], v[MAX_N];double y[MAX_N], INF;//判断是否满足条件bool C(double x){ for (int i = 0; i &lt; n; ++i){ y[i] = v[i] - w[i] * x; } sort(y, y + n); //计算最大的 K 个 yi 的和 double sum = 0; for (int i = 0; i &lt; k; ++i){ sum += y[n - 1 - i]; } return sum &gt;= 0;}void solve(){ double l = 0, r = INF; for (int i = 0; i &lt; 100; ++i){ double md = (l + r) / 2; if (C(md)) l = md; else r = md; } printf(\"%.2f\\n\", l); 查找第 K 个值如果是有序序列（比如：数组），我们可以直接读取第 k 个值，但是有时候我们并不能高效地定位到第 k 个值，或者第 K 个值是动态的，比如二维矩阵、动态查询等，这时候我们可以尝试考虑二分查找。 利用二分来查找第 k 个值，一般基于这么一个判断：设定一个值 x，如果 x 小于第 k 个值，那么小于等于 x 的个数一定小于 k；反过来如果 x 大于等于第 k 个值，那么小于等于 x 的个数一定不小于 k，这其实就是一个假定判断，因此这种方法的核心就是计数。 ps ：在有序的序列中，upper_bound 和 lower_bound 能非常方便的计算小于某个值的个数。 例题：leetcode 668. 乘法表中第k小的数 几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？乘法表是大小为 m x n 的一个整数矩阵，其中 mat[i][j] == i * j（下标从 1 开始）。给你三个整数 m、n 和 k，请你在大小为 m x n 的乘法表中，找出并返回第 k 小的数字。 参考思路：就是使用上面的判断方法来进行二分，关键是计数,由于，因此，可知每一行小于等于 x 的个数为。 12345678910111213141516171819202122class Solution {public: int findKthNumber(int m, int n, int k) { if(m&gt;n) swap(m,n); int l=1; int r=9e8; while(l&lt;=r){ int mid=l + (r-l)/2; if(calc(m,n,mid)&lt;k) l=mid+1; else r=mid-1; } return l; } int calc(int m, int n,int mid){ int res=0; for(int i=1;i&lt;=m;++i){ res+=n*i&lt;=mid?n:mid/i; } return res; }}; 最小（大）化第 K 值例题：POJ 2010 Moo University - Financial Aid“ 农场新建了一所奶牛大学，想从一共 头牛中招收 头牛作为学生（，而且 是奇数），每头牛都有一个如下前的考试分数 和一个需要补助的学费 。但是目前大学总的补助经费只有 ，因此不能随意招收任意的奶牛。现在你是招生办主任，你要在不超过补助经费 的情况下，从 头牛中选 头录取，并且分数中位数最大。 思路分析： 由于N是奇数，因此就是让第 N/2 + 1 高的分数最大，怎么办？我们可以先考虑最暴力的解法，求出所有的符合条件的 N头牛的不同组合，然后对比这些组合中第 N/2 + 1 高的分数，那个最大。但是组合数太大了，而且如果我们把每个组合的分数排序然后取第 N/2 + 1 个分数，那总的时间复杂度需要​ 如果我们像上面那样使用二分来取第 K 大值呢，好像时间复杂度还是 O(NlogN)，但是它可以使用一些贪心算法，我们没必要比对每个组合。我们回忆一下上面求第 K 大值的方法，我们根据当前小于等于 x 的个数 count 来决定 x 是该增大还是减少，假如 count 小于 K，那么 x 就可以增大。那么回到当前，如果这些组合里面至少存在一个组合的 count 比 K 小，那么 x 就可以增大了，换句话说只要存在有 count 比 K 小，x 就可以增大，那么我们是不是可以只和最小的 count 比就行了。那么我们如何让比 x 小的个数尽量少呢？在经费不超过 F 的情况下，尽量选分数比 x 大就行。但是需要额外先判断是否存在解，只有一定存在解才进入二分的逻辑，可以避免特殊边界的判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAX_C=100010;int N,C,F,L[MAX_C],R[MAX_C];struct cow{ int c,f;}cows[MAX_C];int cmp(const cow&amp; a, const cow&amp; b){ return a.c&lt;b.c;}// 标签：二分 最小化第 K 大的值 int calc(int x){ for(int i=0;i&lt;C;++i){ L[i]=cows[i].f; } int i,j,l,r; for(i=0,l=0,r=0;i&lt;C;++i){ if(cows[i].c&lt;=x) L[l++]=cows[i].f; else R[r++]=cows[i].f; } int res=0; sort(L,L+l);//分数小于等于 x 的奶牛的补助放到一个数组，称为左边 sort(R,R+r);//分数比 x 大的奶牛的补助放到一个数组，称为右边 LL s=0,cnt=0; for(i=0;cnt&lt;N&amp;&amp;i&lt;r;++i) s+=R[i],++cnt;//优先右边选，并且从小往大选，这样能选尽量多。 j=i; for(i=0;i&lt;l&amp;&amp;cnt&lt;N;++i) s+=L[i],++cnt;//如果右边的奶牛总算不够 N 头，从左边补够N头。 for(;i&lt;l&amp;&amp;s&gt;F;++i) s+=L[i]-R[--j];//如果总的补助大于 F，那么把右边最大替换掉，再用左边较小的替换。 res=i;//左边一共选择了多少头，就是有多个分数小于等于 x。 return res;}// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d %d\",&amp;N,&amp;C,&amp;F); for(int i=0;i&lt;C;++i){ scanf(\"%d %d\",&amp;cows[i].c,&amp;cows[i].f); L[i]=cows[i].f; } sort(L,L+C); LL s=0; int ans=-1; for(int i=0;i&lt;N;++i) s+=L[i]; //判断是否无解，如果无解不需要二分 if(s&lt;=F){ sort(cows,cows+C,cmp); int l=0,r=C-1,k=N/2+1; while(l&lt;=r){ int md=(l+r)/2; if(calc(cows[md].c)&lt;k) l=md+1; else r=md-1; } ans=cows[l].c; } printf(\"%d\\n\",ans); return 0;} 例题：POJ 3662 Telephone Lines FJ 想在电话公司和自己的农场之间建立电话线路，它们之间有 n 根电线杆，1 和 n 号电线杆分别在电话公司和农场内，这些电线杆之间有的可以相互连接(a,b,l 表示a 和 b 连接的费用是 l)，有的不行。电话公司愿意支付 k 根最贵的电话线，剩下的电话线中最贵的一根的费用就是 FJ 需要支付的最终费用。求 FJ 可以建立电话线路需要的最小费用。 解题思路：这是一张无向图，如果 1 和 n 之间非连通，则返回 -1，如果连通需要的最少边数小于等于 k 则费用是0，如果边数大于 k ，则第 k+1 贵的电线就是 FJ 要支付的费用，因此问题就是最小化第 k+1大的值。 连通性和连通的最少边数可以使用 BFS 求出，这个非常简单，问题是如何才能最小化第 K+1 大的值。不妨先想办法找出每条路径第 k+1 大的值，然后取它们中的最小值，总体上的思路和上面 POJ 2010 类似，使用二分 + 贪心。我们依然使用 x 来判断，如果大于等于 x 的边数 count 少于 k+1，那么说明 x 还可以更小，因此我们只需要和最小的 count 比就行。我们设大于等于 x 的边权为 1，其他为 0，那么最小的 count 就是最短路径，可以使用 dijkstra 算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int P=20100; // 要记得向前星无向边的容量是边数的两倍const int N=1010;int n,p,k,d[N],e[P];priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt;&gt; pq; //小根堆struct Edge{ int to, w,next;}edges[P];int id,head[P];void add(int u, int v, int w){ edges[++id].to=v; edges[id].next=head[u]; edges[id].w=w; head[u]=id;}int djk(int x){ memset(d,-1,sizeof(d)); while(pq.size()) pq.pop(); //这里一定要注意清空队列 d[1]=0; pq.push(make_pair(0,1)); while(pq.size()){ pi t=pq.top(); pq.pop(); int w=t.first, u=t.second; if(u==n) break; if(d[u]!=-1&amp;&amp;d[u]&lt;w) continue; for(int i=head[u];i;i=edges[i].next){ int v=edges[i].to; if(d[v]==-1||(d[v]&gt;d[u]+(edges[i].w&gt;=x))){ d[v]=d[u] + (edges[i].w&gt;=x); pq.push(make_pair(d[v],v)); } } } return d[n];}//#define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d %d\",&amp;n,&amp;p,&amp;k); int u,v,w; for(int i=0;i&lt;p;++i){ scanf(\"%d %d %d\",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); e[i]=w; } int mik=djk(0); if(mik&lt;0) printf(\"%d\\n\",-1); else if(mik&lt;=k) printf(\"%d\\n\",0); else { sort(e,e+p); int l=1,r=p-1; while(l&lt;=r){ int md=(l+r)/2; int ret=djk(e[md]); if(ret&lt;k+1) r=md-1; else l=md+1; } printf(\"%d\\n\",e[r]); }} 通过上面的两条例题可以看出，最小化第 K 大值，是通过二分查找第 K 值 + 贪心 来实现的，二分查找第 K 值 中我们通过计算小于等于 x 的个数来判断 x 是在第 K 值的左边还是右边，而这里则使用最优的方案来计算小于等于 x 的个数，因此最后得出的第 K 值也是最优的。 其他折半舍去我们在判断一条题目是否可以使用二分的时候，最常用的一个方法就是判断其是否具有单调性，但其实只要能保证每次迭代的区间一定存在解，那么通过区间收敛就一定能获取解，单调性能比较容易看出并且实现这一点，但并不代表只有单调性才能使用二分。 例题：leetcode 852. 山脉数组的峰顶索引 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i。0&lt;i&lt;arr.length-1; 思路分析：如果区间 [l,r] 存在顶点，那么对于区间的 x， 如果有 arr[x+1]&gt;arr[x]，那么顶点一定在 [x+1,r]，反过来如果 arr[x]&gt;arr[x+1]，那么顶点一定在 [l,x]。 123456789101112class Solution { public int peakIndexInMountainArray(int[] arr) { int n=arr.length; int l=0, r=n-1; while(l&lt;r){ int md=(l+r)/2; if(arr[md+1]&gt;arr[md]) l=md+1; else r=md; } return l; }} 例题：Uva 1607 与非门电路 参考思路： 因为 n 个输入接收同一个 x，因此整个电路的功能无非就是 4 种：常数 0；常数 1；x，非 x。 我们可以先把所有的 x 全部设置为 0，再设置为 1，如果两者输出一致，那说明结果是常数，那么可以把所有的输入全部设置成 0，或者全部设置成 1。 如果输出不同，那么我们可以只需要讨论其中一种，因为它们逻辑是一样的。我们设 x=0时候，输出 0；x=1 时候，输出 1。现在我们把第一个输入改成 1，其他还是 0，如果输出是 1，那么就得到一个解 x00...00；如果输出还是 0 ，再把第二个也改成 1，如果输出 1，则又找到一个解 1x00...0，如果还是 0，再继续尝试11100...00，如此等等。由于全为 1 的时候，则一定会输出 1，这表示一定存在解。那为什么不直接使用 111...1x 呢？ 因为虽然全为 1 时输出一定为 1，但是 11...10 输出不一定为0，也有可能为 1，那么 111...1x 输出就变成了常数。 我们设输入为个时的输出那么如果存在 f(i)=0 和f(i+1)=1 ，则 i 和 i+1 就是我们要找的临界点，题目中可能会存在多个这样的临界点，但是我们只需要找到其中一个即可。我们设区间[l,r]满足f(l)=0 和 f(r)=1，那么如果区间中的 i 有 f(i)=0，那么区间可以缩小为[i,r]，反之如果f(i)=1，那么区间可以缩小为[l,i]，最终收敛为 (i,i+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100010;const int M=200010;struct gate{ int a,b,o;}gates[M];int n,m;int calc(int cnt){ for(int i=1;i&lt;=m;++i){ int a=gates[i].a; int b=gates[i].b; int ia=a&lt;0?(-a&lt;=cnt):gates[a].o; int ib=b&lt;0?(-b&lt;=cnt):gates[b].o; gates[i].o=~(ia&amp;ib); gates[i].o&amp;=1; } return gates[m].o;}// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif int T; scanf(\"%d\",&amp;T); while(T--&gt;0){ scanf(\"%d %d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(\"%d %d\",&amp;gates[i].a,&amp;gates[i].b); } int u=calc(0); int v=calc(n); if(u==v){ for(int i=0;i&lt;n;++i) printf(\"%c\",'1'); printf(\"\\n\"); }else{ int l=0,r=n; while(l&lt;r){ int md=(l+r)/2; if(calc(md)==u) l=md+1; else r=md; } char ch; for(int i=1;i&lt;=n;++i){ ch=i&lt;r?'1':(i==r?'x':'0'); printf(\"%c\",ch); } printf(\"\\n\"); } } return 0;} 参考资料《算法竞赛入门经典-第 2 版》 《挑战程序设计竞赛》 《oi-wiki》 《leetcode 网站》","link":"/blog/2024/02/04/binary_search/"},{"title":"双指针（二）","text":"链表上的双指针例题：leetcode 142. 环形链表 II 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* slow=head; ListNode* fast=head; while(fast){ if(fast-&gt;next==nullptr) break; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast){ fast=head; while(fast!=slow){ slow=slow-&gt;next; fast=fast-&gt;next; } return slow; } } return nullptr; }}; 例题：leetcode 19. 删除链表的倒数第 N 个结点12345678910111213141516class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dumy=new ListNode(0); dumy-&gt;next=head; ListNode *a=dumy,*b=dumy; while(n--&gt;0) b=b-&gt;next;//先让 b 节点先走 n 个节点 while(b-&gt;next){ a=a-&gt;next; b=b-&gt;next; } //结束时候，b 多走了 n 个节点，也就是 a 后面还有 n 个节点，a 是倒数第 n 个节点的前缀。 a-&gt;next=a-&gt;next-&gt;next; return dumy-&gt;next; }}; 树上双指针例题：luogu P3066 Running Away From the Barn G给定一颗 nn 个点的有根树，边有边权，节点从 1 至 n 编号，1 号节点是这棵树的根。再给出一个参数 t，对于树上的每个节点 u，请求出 u 的子树中有多少节点满足该节点到 u 的距离不大于 t。 思路分析：如果对树进行深度遍历，那么对于任意一条路径来说，它上面的节点的边权前缀和肯定是单调递增的，因此我们在遍历的过程中，如果把&lt;前缀和,路径节点&gt;按顺序保存起来，这样就变成了一个典型的滑动窗口问题。我们可以对当前遍历的路径使用滑动窗口来保持一个符合要求的区间，由于该区间的每一个父节点都让最终答案 +1，因此对这些区间使用树上差分，最终对差分求和就是最后答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL,int&gt; pil;const int N=200010;struct Edge{ int to,nxt; LL w;}edges[N&lt;&lt;1];int head[N&lt;&lt;1],idx;int n,tot=0,l=0;LL t,d[N];pil st[N];void add(int u, int v, LL w){ edges[++idx].to=v; edges[idx].w=w; edges[idx].nxt=head[u]; head[u]=idx;}void dfs(int u, int p, LL w){ st[tot++]={w,u}; int preL=l; while(st[l].first&lt;w-t) l++;//移动左边的指针，保持区间和满足要求 if(l&gt;0) d[st[l-1].second]--;//差分数组，第 l - 1 个-- d[u]++; for(int i=head[u];i;i=edges[i].nxt){ if(edges[i].to==p) continue; dfs(edges[i].to,u,edges[i].w+w); } tot--; l=preL;//当前节点出栈后，需要把 l 设置为之前的位置。}//树上差分求和void calc(int u, int p){ for(int i=head[u];i;i=edges[i].nxt){ if(edges[i].to==p) continue; calc(edges[i].to,u); d[u]+=d[edges[i].to]; }}int main(){ scanf(&quot;%d %lld&quot;,&amp;n,&amp;t); LL p,w; for(int i=2;i&lt;=n;++i){ scanf(&quot;%lld %lld&quot;,&amp;p,&amp;w); add(p,i,w); } dfs(1,0,0LL); calc(1,0); for(int i=1;i&lt;=n;++i) printf(&quot;%lld\\n&quot;,d[i]); return 0;} 参考资料《算法竞赛入门经典 第2版》 《挑战程序设计竞赛》 《leetcode》 《oi-wiki》","link":"/blog/2024/02/05/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"VMWare Player 安装Centos 7","text":"对于学习技术来说，VMware Player + CentOS 可以算得上一对相当不错的免费工具组合，本文就是描述如何在 VMware Player 安装 CentOS 7，并且如何通过手动的方式克隆虚拟机。 虚拟机：VMware Workstation 16 Player 操作系统：CentOS Linux release 7.7.1908 创建新虚拟机实例 点击创建新虚拟机 选择安装来源：稍后安装操作系统 选择客户机操作系统：Linux 设置该虚拟机实例名称和工作目录（存储该虚拟机相关的所有文件） 设置硬盘大小： 参考：40 G；选择“将虚拟机硬盘拆分成多个文件” 点击完成 点击编辑虚拟机实例设置 网络适配器：桥接模式 CD/DVD：使用 IOS 影像文件 -》 选择上面下载的 CentOS 7 ISO 文件 安装 CentOS 7安装系统 选择虚拟机实例，点击播放虚拟机 进入安装界面：Install CentOS 7 进入安装语言界面：中文 -》 简体中文（中国）-》 继续 进入安装信息摘要界面：点击安装位置 -》 选择我要配置分区 进入手动分区界面：点击自动创建他们 我的手动分区参考： /boot: 1024 /：25 GiB swap: 3968 MiB /home：10 GiB /home 分区需要手动改创建 先把 / 分区减少 10 G 空间 点击左下 + 号按钮 挂载点：下拉选择 /home 期望容量： 10 GiB 点击添加挂载点 手动分区完成，返回安装信息摘要界面，点击开始安装 安装过程中会出现配置界面，点击 Root 密码配置选项，设置 root 密码 等待安装完成 -》 点击完成配置 -》 点击重启 配置网络重启进入登录界面，输入root账号和密码登录，并查看当前网络接口名称： 1234567891011[root@localhost ~]# ip addr list1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:ca:2b:a0 brd ff:ff:ff:ff:ff:ff inet6 fe80::25c7:c0dc:4aeb:8e4/64 scope link noprefixroute valid_lft forever preferred_lft forever CentOS 7 默认的网络接口名称是 ens33，编辑该网络接口配置文件： 1234567891011121314151617181920[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-ens33TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static # 配置为静态 IPDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=70257dc8-749f-4109-a705-574684642ab8DEVICE=ens33IPADDR=192.168.3.131 # IPNETMASK=255.255.255.0 # 掩码GATEWAY=192.168.3.1 # 网关DNS1=192.168.3.1 # DNS 可以配多个，比如：DNS2，DNS3ONBOOT=yes # 开机自动加载 重启网络服务： 1[root@localhost ~]# systemctl restart network 可以跟尝试跟同网段的其他主机互 PING，测试是否能相互通信。 注意：windows 10 防火墙可能会拦截 PING 请求，测试时需要关闭防火墙。 使用SSH客户端登录 CentOSLinux的连接终端有很多，我这里使用的是开源的putty 输入账号密码登录成功： VMware Workstation Player 克隆虚拟机实例如果你使用的是 VMware Workstation Pro，可以直接使用其提供的克隆功能，但是如果你使用的是 VMware Workstation Player，则可以通过文件拷贝的方式来进行虚拟机克隆。 拷贝工作目录 如果需要拷贝的虚拟机正在运行，则先关闭。 打开 VMware Workstation Player，主页虚拟机列表-》选择需要拷贝的虚拟机-》编辑虚拟机设置 -》 选项 -》 确认工作目录路径。 拷贝工作目录，并对新的工作目录进行重命名。 启动拷贝的虚拟机 VMware Workstation Player 主页 -》 点击打开虚拟选项。 选择刚刚拷贝的文件夹，点击进去会发现一个 后缀为“.vmx”的文件，选择打开。 此时 VMware Workstation Player 主页虚拟机列表会出现一个新的同名虚拟机。 选择新的同名虚拟机 -》 编辑虚拟机 -》 选项 -》 虚拟机名称 -》 重新命名虚拟机。 选择虚拟机 -》 播放虚拟机 -》 弹出对话框 -》 我已复制该虚拟机。 重新配置虚拟机网络使用 root 账号登录，密码和源虚拟机一样，编辑网络接口配置文件： 1234[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-ens33...IPADDR=192.168.3.132 # 修改 IP ... 由于是克隆，因此需要修改 ens33 的 UUID： 1sed -i &quot;/UUID=/cUUID=$(uuidgen ens33)&quot; /etc/sysconfig/network-scripts/ifcfg-ens33 修改主机名称： 1hostnamectl set-hostname node2 重启网络服务： 1systemctl restart network 虚拟机克隆完毕。","link":"/blog/2024/02/27/Linux/VMWare%20Player%20%E5%AE%89%E8%A3%85Centos%207/"},{"title":"Mysql 一主二从（2）- 环境搭建","text":"上一章 《Mysql 一主二从（1）- 架构描述》中，给出了架构的实现和部署图，这一章将描述如何通过虚拟机构建实验的基础环境：创建三个节点，并同时配置节点之间的 SSH 免密登录。 创建虚拟机节点参考文章《VMWare Player 安装Centos 7》创建三个虚拟机节点： 操作系统：CentOS 7 主机名称：node1，node2，node3 网络地址：192.168.3.131，192.168.3.132，192.168.3.132 主机名解析在每个节点的 /etc/hosts 都添加如下内容： 123192.168.3.131 node1192.168.3.132 node2192.168.3.133 node3 ssh 免密登录在 node1 上创建脚本 ~/bin/ssh_rsa_gen： 12345678910111213141516171819#!/bin/bash# 注意： 需要添加 ~/bin 路径当前环境变量；需要添加 ssh_rsa_gen 的执行权限。nodes=(&quot;node1&quot; &quot;node2&quot; &quot;node3&quot;)ssh_user=rootlocal_node=`hostname`# 生成密钥对ssh-keygen -t rsa -N '' -f ~/.ssh/id_rsa# 把公钥 id_rsa.pub 的内容追加到每个节点（包括自身）的 ~/.ssh/authorized_keys 文件for node in &quot;${nodes[@]}&quot;do scp ~/.ssh/id_rsa.pub $ssh_user@$node:/tmp/ [ $? -ne 0 ] &amp;&amp; exit 1 ssh $ssh_user@$node &quot;mkdir -pv ~/.ssh &amp;&amp;\\ cat /tmp/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys &amp;&amp;\\ chmod go= ~/.ssh/authorized_keys &amp;&amp;\\ rm -rf /tmp/id_rsa.pub&quot;done 在 node1 上执行脚本，脚本执行过程中会被多次要求输入密码： demo >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@node3 ~]# ssh_rsa_genGenerating public/private rsa key pair.Created directory '/root/.ssh'.Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:AeAWRarFpbiVTgJ8tKTCYhatWd9pGdJZnbyAwxxnJbc root@node3The key's randomart image is:+---[RSA 2048]----+|o.ooo+O.==+o. ||.o+B.B Xo.o+. ||o=B.% o * .E. ||=o X . = . . || o . . S || || || || |+----[SHA256]-----+The authenticity of host 'node1 (192.168.3.131)' can't be established.ECDSA key fingerprint is SHA256:JiNjfTMhq+/0CEDeTq1wGH+W6X+2/xYuHhBC3YHsK4w.ECDSA key fingerprint is MD5:71:0e:23:35:b6:1a:49:81:33:ec:9c:54:46:49:08:ec.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'node1,192.168.3.131' (ECDSA) to the list of known hosts.root@node1's password:id_rsa.pub 100% 392 264.8KB/s 00:00root@node1's password:mkdir: 已创建目录 &quot;/root/.ssh&quot;The authenticity of host 'node2 (192.168.3.132)' can't be established.ECDSA key fingerprint is SHA256:JiNjfTMhq+/0CEDeTq1wGH+W6X+2/xYuHhBC3YHsK4w.ECDSA key fingerprint is MD5:71:0e:23:35:b6:1a:49:81:33:ec:9c:54:46:49:08:ec.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'node2,192.168.3.132' (ECDSA) to the list of known hosts.root@node2's password:id_rsa.pub 100% 392 294.0KB/s 00:00root@node2's password:mkdir: 已创建目录 &quot;/root/.ssh&quot;The authenticity of host 'node3 (192.168.3.133)' can't be established.ECDSA key fingerprint is SHA256:JiNjfTMhq+/0CEDeTq1wGH+W6X+2/xYuHhBC3YHsK4w.ECDSA key fingerprint is MD5:71:0e:23:35:b6:1a:49:81:33:ec:9c:54:46:49:08:ec.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'node3,192.168.3.133' (ECDSA) to the list of known hosts.root@node3's password:id_rsa.pub 100% 392 485.1KB/s 00:00root@node3's password: 把脚本复制到其他节点，此时 scp 命令已经不需要输入密码： demo >folded1234[root@localhost ~]# scp ~/bin/ssh_rsa_gen node2:~/bin/ssh_rsa_gen 100% 451 234.8KB/s 00:00[root@localhost ~]# scp ~/bin/ssh_rsa_gen node3:~/bin/ssh_rsa_gen 100% 451 272.8KB/s 00:00 远程登录其他节点并执行脚本： demo >folded123456789101112131415[root@localhost ~]# ssh node2Last login: Wed Feb 28 22:59:26 2024 from node1[root@node2 ~]# ssh_rsa_gen....[root@node2 ~]# exit登出Connection to node2 closed.[root@localhost ~]# ssh node3Last login: Wed Feb 28 22:44:57 2024 from node1[root@node3 ~]# ssh_rsa_gen...[root@node3 ~]# exit登出Connection to node3 closed.","link":"/blog/2024/03/07/Mysql/Mysql%20%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%EF%BC%882%EF%BC%89-%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"Mysql 安装 - yum 安装","text":"","link":"/blog/2024/03/02/Mysql/Mysql%20%E5%AE%89%E8%A3%85%20-%20yum%20%E5%AE%89%E8%A3%85/"},{"title":"Mysql 安装 - Centos 7 二进制包安装","text":"二进制包安装可以指定任意安装路径，灵活性好，同时一台服务器可以安装多个版本的 Mysql 软件。 操作系统：CentOS Linux release 7.7.1908 MYSQL：mysql-8.0.27 安装过程和配置仅仅作为参考，你应该根据自己的环境进行调整。 文章最后提供二进制包自动安装脚本 创建 mysql 用户 123groupadd -r mysqluseradd -g mysql -r -M mysqlchown -R mysql:mysql /data/mysql 下载和安装123456789# 下载到安装包到 /tmpwget -P /tmp https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.27-linux-glibc2.12-x86_64.tar.xz# 解压安装包到 /usr/localtar -xvf /tmp/mysql-8.0.27-linux-glibc2.12-x86_64.tar.xz -C /usr/local# 设置软链接：ln -sv /usr/local/ $base_dir # 修改 MYSQL 文件属主cd /usr/local/mysqlchown -R mysql:mysql ./ 配置创建 MYSQL 相关目录和文件 >folded12345678910mkdir /data/mysql -pv # 数据目录mkdir /var/log/mysql -pv # mysqld 日志目录touch /var/log/mysql/mysqld.log # error-log-filemkdir /var/lib/mysql -pv mkdir /var/run/mysqld -pv# 修改文件目录所属chown -R mysql:mysql /data/mysqlchown -R mysql:mysql /var/lib/mysqlchown -R mysql:mysql /var/log/mysqlchown -R mysql:mysql /var/run/mysqld 配置环境变量 >folded1234vim /etc/profile.d/mysql.shexport MYSQL_HOME=$base_direxport PATH=$MYSQL_HOME/bin:$PATH 刷新环境变量 >folded1source /etc/profile.d/mysql.sh 配置 systemd >folded1234cp /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqldchmod +x /etc/rc.d/init.d/mysqld/sbin/chkconfig --add mysqld/sbin/chkconfig mysqld on 配置 mysql lib >folded123ln -sv /usr/local/mysql/include /usr/include/mysql echo &quot;/usr/local/mysql/lib&quot; &gt; /etc/ld.so.conf.d/mysql.conf ldconfig 配置 /etc/my.cnf >folded1234567891011121314151617181920212223242526272829303132[client]socket=/var/lib/mysql/mysql.sockport=3306[mysql]prompt=&quot;\\\\u@\\\\h \\\\d \\\\r:\\\\m:\\\\s&gt;&quot;auto-rehash[mysqld]port=3306basedir=/usr/local/mysqldatadir=/data/mysql/datasocket=/var/lib/mysql/mysql.sockpid-file=/var/run/mysqld/mysqld.pid# mysql service loglog_error=/var/log/mysql/mysqld.logslow_query_log=ONslow_query_log_file=/var/log/mysql/slow-query.loglong_query_time=10log_queries_not_using_indexes=1log_slow_admin_statements=1# binary loglog_bin=/data/mysql/binlog/mysql-binlog_bin_index=/data/mysql/binlog/mysql-bin.indexbinlog_format=rowbinlog_rows_query_log_events=onsync_binlog=1 #表示每次事务的 binlog 都会fsync持久化到磁盘，MySQL 5.7.7 之后默认为1，之前的版本默认为0innodb_flush_log_at_trx_commit=1 #表示每次事务的 redo log 都直接持久化到磁盘，默认值为1 初始化 MYSQL执行初始化命令 >folded12# $MYSQL_HOME:/usr/local/mysql[root@node1 ~]# /usr/local/mysql/bin/mysqld --initialize --user=mysql 查看 'root'@'localhost' 的初始密码 >folded1234567891011# 初始密码打印在 log_error 文件中，该路径配置在 /etc/my.cnf [root@node1 ~]# tail -30 /var/log/mysql/mysqld.log2024-03-03T12:13:39.218978Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.27) initializing of server in progress as process 29432024-03-03T12:13:39.232758Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.2024-03-03T12:13:39.761340Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.2024-03-03T12:13:40.766867Z 0 [Warning] [MY-013746] [Server] A deprecated TLS version TLSv1 is enabled for channel mysql_main2024-03-03T12:13:40.766883Z 0 [Warning] [MY-013746] [Server] A deprecated TLS version TLSv1.1 is enabled for channel mysql_main# 冒号后面的内容就是 root@localhost 的初始化密码2024-03-03T12:13:40.798911Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 1iwve;lr)vZ4 .... 或者使用 grep 命令直接读取初始化密码 >folded1grep 'A temporary password is generated for root@localhost' /var/log/mysql/mysqld.log | tail -1 | grep -o 'root@localhost: .*' | awk '{print $2}' 启动 mysql >folded1service mysqld start 使用初始密码登录 MYSQL，并修改 'root'@'localhost' 密码： >folded12345# mysql 8.0 账号默认使用 'caching_sha2_password' 认证插件alter user 'root'@'localhost' identified by 'yourpassword'# 指定 mysql_native_passwordalter user 'root'@'localhost' identified with mysql_native_password by 'yourpassword' 关闭 mysql >folded1service mysqld stop 退出，使用新密码重新登录，安装完成~ 安装脚本 安装配置：mysql_config，根据安装环境的需要修改 安装命令：mysql_install 使用前：安装 wget 使用后：使用命令 source /etc/profile.d/mysql.sh 刷新当前窗口的环境变量 卸载命令：mysql_uninstall 辅助脚本：script_helper.sh 脚本存放路径：所有脚本需要放在同一路径之下 mysql_config >folded123456789101112131415161718192021222324252627#!/bin/bashpackage_name=mysql-8.0.27-linux-glibc2.12-x86_64package_suffix=.tar.xzpackage_file=$package_name$package_suffixpackage_url=https://cdn.mysql.com/archives/mysql-8.0/$package_file# 输入 base_dir_prefix ，使用默认值(/usr/local)，直接回车read -p &quot;base_dir_prefix(default /usr/local): &quot; base_dir_prefixbase_dir_prefix=${base_dir_prefix:-&quot;/usr/local&quot;}# 安装目录install_dir=$base_dir_prefix/$package_name# MYSQL_HOMEbase_dir=$base_dir_prefix/mysql# 输入 data_dir_prefix，使用默认值(/data/mysql)，直接回车read -p &quot;data_dir_prefix(default /data/mysql): &quot; base_dir_prefixdata_dir_prefix=${data_dir_prefix:-&quot;/data/mysql&quot;}# 表数据存储目录data_dir=$data_dir_prefix/data# 二进制日志存储目录binlog_dir=$data_dir_prefix/binloglog_dir=/var/log/mysqlerror_log_file=$log_dir/mysqld.loglib_dir=/var/lib/mysqlrun_dir=/var/run/mysqld mysql_install >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!/bin/bashsource ./script_helper.shsource ./mysql_configLOG_LEVEL=2# read variables# 输入端口，使用默认值(3306)，直接回车read -p &quot;mysqld port(default 3306): &quot; portport=${port:-3306}# 输入 server_id，使用默认值(1)，直接回车read -p &quot;server_id(default 1): &quot; server_idserver_id=${server_id:-1}# 输入需要设置的 root@localhost 的密码，使用默认值(初始化自动生成的密码)，直接回车read -s -p &quot;root@locahost's password(default init password): &quot; rootpass# create mysql userlog_info &quot;create user mysql:mysql...&quot;groupadd -r mysql &gt;&amp; /dev/null &amp;&amp;useradd -g mysql -r -M mysql &amp;&gt;/dev/nullid mysql[ &quot;$?&quot; -ne 0 ] &amp;&amp; exit 1;# load mysqllog_info &quot;loading mysql...&quot;wget -P /tmp $package_url &amp;&amp;tar -xvf /tmp/$package_file -C $base_dir_prefix &amp;&amp;ln -sv $install_dir $base_dir &amp;&amp;rm -rf /tmp/$package_file[ &quot;$?&quot; -ne 0 ] &amp;&amp; exit 1;# create dir and filelog_info &quot;create mysql-related files and directories....&quot;mkdir -pv $data_dir $binlog_dir $log_dir $lib_dir $run_dir &amp;&amp;touch $error_log_file &amp;&amp;chown -R mysql:mysql $data_dir_prefix $log_dir $lib_dir $run_dir[ &quot;$?&quot; -ne 0 ] &amp;&amp; exit 1;# setting mysql profilelog_info &quot;setting mysql profile...&quot;cat &gt; /etc/profile.d/mysql.sh &lt;&lt; EOFexport MYSQL_HOME=$base_direxport PATH=\\$MYSQL_HOME/bin:\\$PATHEOFsource /etc/profile.d/mysql.sh[ $? -ne 0 ] &amp;&amp; exit 1;# configuring systemd for mysqldlog_info &quot;configuring systemd for mysqld...&quot;cp $base_dir/support-files/mysql.server /etc/rc.d/init.d/mysqld &amp;&amp;chmod +x /etc/rc.d/init.d/mysqld &amp;&amp;/sbin/chkconfig --add mysqld &amp;&amp;/sbin/chkconfig mysqld on[ $? -ne 0 ] &amp;&amp; exit 1;# add mysql manlog_info &quot;add mysql man...&quot;cat &gt;&gt; /etc/man.config &lt;&lt; EOFMANPATH $base_dir/manEOF[ $? -ne 0 ] &amp;&amp; log_warn &quot;cp mysql.server to init.d failed&quot;;# configurate mysql liblog_info &quot;config mysql lib...&quot;ln -sv $base_dir/include /usr/include/mysql &amp;&amp;echo &quot;$base_dir/lib&quot; &gt; /etc/ld.so.conf.d/mysql.conf &amp;&amp;ldconfig[ $? -ne 0 ] &amp;&amp; log_warn &quot;configurate mysql lib failed&quot;;####################### setting /etc/my.cnf ################################################log_info &quot;setting my.cnf...&quot;cat &gt; /etc/my.cnf &lt;&lt; EOF[client]socket=$lib_dir/mysql.sockport=$port[mysql]prompt=&quot;\\\\u@\\\\h \\\\d \\\\r:\\\\m:\\\\s&gt;&quot;auto-rehash[mysqld]port=$portbasedir=$base_dirdatadir=$data_dirsocket=$lib_dir/mysql.sockpid-file=$run_dir/mysqld.pid# mysql service loglog_error=$error_log_fileslow_query_log=ONslow_query_log_file=$log_dir/slow-query.loglong_query_time=10log_queries_not_using_indexes=1log_slow_admin_statements=1# binary loglog_bin=$binlog_dir/mysql-binlog_bin_index=$binlog_dir/mysql-bin.indexbinlog_format=rowbinlog_rows_query_log_events=onsync_binlog=1 #表示每次事务的 binlog 都会fsync持久化到磁盘，MySQL 5.7.7 之后默认为1，之前的版本默认为0innodb_flush_log_at_trx_commit=1 #表示每次事务的 redo log 都直接持久化到磁盘，默认值为1EOF[ $? -ne 0 ] &amp;&amp; exit 1;######################## initalize mysql ######################################################################log_info &quot;initalize mysql...&quot;$MYSQL_HOME/bin/mysqld --initialize --user=mysqltmppwd=`grep 'A temporary password is generated for root@localhost' $error_log_file | tail -1 | grep -o 'root@localhost: .*' | awk '{print $2}'`log_debug &quot;tmp password:$tmppwd&quot;service mysqld startmysql -uroot -p${tmppwd} --connect-expired-password -e &quot;alter user 'root'@'localhost' identified by '$rootpass';&quot;service mysqld stopsystemctl enable mysqld mysql_uninstall >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/bin/bashsource ./script_helper.shsource ./mysql_configLOG_LEVEL=2################## uninstall mysql #######################################################function uninstall_mysql(){kill_process_by_name mysqld;systemctl disable mysqld &amp;&gt; /dev/null;test -f $pid_file &amp;&amp; rm -rf $pid_file;test -f $sock_file &amp;&amp; rm -rf $sock_file;test -d $data_dir_prefix &amp;&amp; rm -rf $data_dir_prefix;test -d $log_dir &amp;&amp; rm -rf $log_dir;test -d $lib_dir &amp;&amp; rm -rf $lib_dir;test -d $run_dir &amp;&amp; rm -rf $run_dirif [ -f /etc/profile.d/mysql.sh ]; then echo &quot;export PATH=\\$PATH&quot; &gt; /etc/profile.d/mysql.sh; source /etc/profile.d/mysql.sh; rm -rf /etc/profile.d/mysql.sh;fiif [ -f &quot;/etc/rc.d/init.d/mysqld&quot; ]; then/sbin/chkconfig mysqld off;/sbin/chkconfig --del mysqld;fitest -f /etc/rc.d/init.d/mysqld &amp;&amp; rm -rf /etc/rc.d/init.d/mysqld;sed -i &quot;/MANPATH \\${base_dir}/d&quot; /etc/man.config;test -L /usr/include/mysql &amp;&amp; unlink /usr/include/mysql;test -f /etc/ld.so.conf.d/mysql.conf &amp;&amp; rm -rf /etc/ld.so.conf.d/mysql.conf;ldconfig;test -f /etc/my.cnf &amp;&amp; rm -rf /etc/my.cnf;test -L $base_dir &amp;&amp; unlink $base_dir;test -d $install_dir &amp;&amp; rm -rf $install_dir;echo &quot;uninstall mysql finish&quot;}check_dir(){test -d $1 &amp;&amp; log_warn &quot;$1 remain&quot; &amp;&amp; exit 1;}check_file(){test -f $1 &amp;&amp; log_warn &quot;$1 remain&quot; &amp;&amp; exit 1;}check_link(){test -L $1 &amp;&amp; log_warn &quot;$1 remain&quot; &amp;&amp; exit 1;}################## uninstall status #######################################################function uninstall_status(){check_dir $base_dir;check_dir $install_dir;check_file /etc/my.cnf;check_link /usr/include/mysql;check_file /etc/ld.so.conf.d/mysql.conf;if [ -z &quot;grep $base_dir/man /etc/man.config&quot; ]; thenlog_warn &quot;mysql man config remain&quot;;exit 1;ficheck_file /etc/rc.d/init.d/mysqld;check_file /etc/profile.d/mysql.sh;check_dir $data_dir_prefix;check_dir $log_dir;check_dir $lib_dir;check_dir $run_dir;echo &quot;uninstall mysql finished&quot;}case &quot;$1&quot; instatus) uninstall_status;;*) uninstall_mysql;;esac script_helper.sh >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bash##### 日志打印 #####LOGG_OPEN=0#日志级别 debug:1, info:2, warn:3, error:4, always:5LOG_LEVEL=3# 调试日志function log_debug(){ content=&quot;[DEBUG] $(date '+%Y-%m-%d %H:%M:%S') $@&quot;; [ $LOG_LEVEL -le 1 ] &amp;&amp; echo -e &quot;\\033[32m&quot; ${content} &quot;\\033[0m&quot;}#信息日志function log_info(){ content=&quot;[INFO] $(date '+%Y-%m-%d %H:%M:%S') $@&quot;; [ $LOG_LEVEL -le 2 ] &amp;&amp; echo -e &quot;\\033[32m&quot; ${content} &quot;\\033[0m&quot;}#警告日志function log_warn(){ content=&quot;[WARN] $(date '+%Y-%m-%d %H:%M:%S') $@&quot;; [ $LOG_LEVEL -le 3 ] &amp;&amp; echo -e &quot;\\033[33m&quot; ${content} &quot;\\033[0m&quot;}#错误日志function log_err(){ content=&quot;[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $@&quot;; [ $LOG_LEVEL -le 4 ] &amp;&amp; echo -e &quot;\\033[31m&quot; ${content} &quot;\\033[0m&quot;}#一直都会打印的日志function log_always(){ content=&quot;[ALWAYS] $(date '+%Y-%m-%d %H:%M:%S') $@&quot;; [ $LOG_LEVEL -le 5 ] &amp;&amp; echo -e &quot;\\033[32m&quot; ${content} &quot;\\033[0m&quot;}##### 进程处理 #####kill_process_by_name(){ #根据进程名杀死进程 if [ $# -lt 1 ]; then echo &quot;缺少参数：pro_name&quot; exit 1 fi # 第一行是获取进程号 PROCESS=`ps -ef | grep $1 | grep -v grep | grep -v PPID | awk '{print $2}'` # 第二行是遍历进程号使用kill-9 结束进程 for i in $PROCESS do echo &quot;Kill the $1 process [ $i ]&quot; kill -9 $i done}","link":"/blog/2024/03/01/Mysql/Mysql%20%E5%AE%89%E8%A3%85%20-%20Centos%207%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AE%89%E8%A3%85/"},{"title":"Mysql 一主二从（1）- 架构描述","text":"需求描述 MYSQL 复制： 保证业务请求已经正确返回的数据一定被写入硬盘。 同时保证集群中任何时候都至少有两个节点拥有完整的数据集。 MYSQL 高可用： 主节点宕机时，能自动进行故障转移，包括提升新的主节点和所有剩余从节点的复制源切换。 故障转移过程中需要保证集群数据的完整性。 故障转移过程对 Client 端透明。 MYSQL 故障恢复：宕机节点恢复时，能尽快追赶复制进度并加入集群。 MYSQL 读写分离：写请求由主节点负责，读请求负载均衡到各个节点，充分利用集群的资源。 负载均衡器： 健康检测：某个 MYSQL 节点宕机时，能自动将该节点从负载均衡列表中去除，反之如果节点重新加入集群能自动加入负载均衡列表。 高可用：主负载均衡器宕机时，能自动快速地切换到备用负载均衡器，并且切换过程对 Client 端透明。 只有三台机器，所有需求都需要在三台机器上实现。 架构图 架构实现 MYSQL 复制 双 1 设置：sync_binlog=1 和 innodb_flush_log_at_trx_commit=1 二进制日志格式：binlog_format = row 增强半同步复制 GTID 模式 MYSQL 高可用： 使用 MHA 实现 MYSQL 的高可用。 浮动 IP: 由 MHA Manager 的故障转移脚本 master_ip_failover 实现，故障转移时会自动转移到新的主节点上。 负载均衡： 基于 keepalived + LVS/DR 的主备高可用负载均衡器 Keepalived 对外提供唯一的虚拟 IP，主负载均衡器宕机时，虚拟 IP 会自动转移到备负载均衡器上。 Client 端双数据源实现读写分离： 写请求绑定到 MYSQL 主节点的浮动 IP。 读请求绑定到负责均衡器的虚拟 IP。 部署部署图 操作系统：CentOS Linux release 7.7.1908 (Core) MYSQL：mysql-8.0.27-linux-glibc2.12-x86_64 MHA Node：mha4mysql-node-0.58 MHA Manager：mha4mysql-manager-0.58 Keepalived：Keepalived v1.3.5","link":"/blog/2024/03/07/Mysql/Mysql%20%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%EF%BC%881%EF%BC%89-%20%E6%9E%B6%E6%9E%84%E6%8F%8F%E8%BF%B0/"},{"title":"Mysql一主二从 （3）- MYSQL 集群搭建","text":"本文将描述如何从零开始搭建一个一主二从的 MYSQL 集群，该集群通过以下特性来满足第一章《Mysql 一主二从（1）- 架构描述》” 中提出的需求： 双一配置：保证业务请求已经正确返回的数据一定被写入硬盘。 增强半同步复制：同时保证集群中任何时候都至少有两个节点拥有完整的数据集。 GTID 复制：故障转移和恢复变得更加安全，方便，快速。 安装 MYSQL分别在 node1，node2 和 node3 上安装 MYSQL yum 安装参考《Mysql 安装 - yum 安装》 压缩包安装参考《Mysql 安装 - Centos 7 压缩包安装》 关闭防火墙在每个节点上分别执行： 12[root@localhost bin]# systemctl stop firewalld[root@localhost bin]# systemctl disable firewalld 配置主从 注意：下面以 node1 为例，每个节点都需要同样配置一次 双 1 设置确认 /etc/my.cnf 中下列参数的配置： 12345[mysqld]#表示每次事务的 binlog 都会fsync持久化到磁盘，MySQL 5.7.7 之后默认为1，之前的版本默认为0sync_binlog=1 #表示每次事务的 redo log 都直接持久化到磁盘，默认值为1innodb_flush_log_at_trx_commit=1 开启 GTID 复制删除 $datadir/auto.cnf 1rm -rf /data/mysql/data/auto.cnf 在 /etc/my.cnf 追加参数： 12345678910111213141516#每个节点的 server_id 必须不同server_id=1#手动启动同步复制，节点恢复时需要人工处理并确认无误后，再手动启动复制skip_slave_start=ON#启动默认为只读read_only=ON# 开启 GTID gtid_mode=ONenforce_gtid_consistency=ON# GTID 模式下从库更新写入 binlog# ON：写入 OFF：不写入log_slave_updates=ON# log_slave_updates=OFF 时起作用# 表示每处理完成 1000 个事务，就对表 mysql.gtid_executed 进行压缩gtid_executed_compression_period=1000 重启 MYSQL 实例 systemctl restart mysql，检测 MYSQL 参数： demo >folded123456789101112131415161718192021222324252627282930313233root@localhost (none) :45: &gt;select @@server_id;+-------------+| @@server_id |+-------------+| 1 |+-------------+1 row in set (0.00 sec)root@localhost (none) :46: &gt;select @@skip_slave_start;+--------------------+| @@skip_slave_start |+--------------------+| 1 |+--------------------+1 row in set, 1 warning (0.00 sec)root@localhost (none) :47: &gt;show variables like '%gtid%';+----------------------------------+-----------+| Variable_name | Value |+----------------------------------+-----------+| binlog_gtid_simple_recovery | ON || enforce_gtid_consistency | ON || gtid_executed | || gtid_executed_compression_period | 0 || gtid_mode | ON || gtid_next | AUTOMATIC || gtid_owned | || gtid_purged | || session_track_gtids | OFF |+----------------------------------+-----------+9 rows in set (0.02 sec)root@localhost (none) :47: &gt; 使用增强半同步模式 判断 Mysql 服务是否支持动态增加插件： 1234567[root@localhost bin]# mysql -uroot -p -e &quot;select @@have_dynamic_loading;&quot;Enter password:+------------------------+| @@have_dynamic_loading |+------------------------+| YES |+------------------------+ 确认是否存在主库 semisync_master.so 和 从库插件 semisync_slave.so： 12345[root@localhost bin]# ll $MYSQL_HOME/lib/plugin/semisync_master.so-rwxr-xr-x. 1 7161 31415 1071400 9月 28 2021 /usr/local/mysql/lib/plugin/semisync_master.so[root@localhost bin]# ll $MYSQL_HOME/lib/plugin/semisync_slave.so-rwxr-xr-x. 1 7161 31415 691048 9月 28 2021 /usr/local/mysql/lib/plugin/semisync_slave.so 安装插件 12345678910111213141516# 考虑到主备切换，因此在主从上都安装两个插件mysql&gt; install plugin rpl_semi_sync_master soname 'semisync_master.so';Query OK, 0 rows affected, 1 warning (0.20 sec)mysql&gt; install plugin rpl_semi_sync_slave soname 'semisync_slave.so';Query OK, 0 rows affected, 1 warning (0.00 sec)# 查看已安装的插件mysql&gt; select * from mysql.plugin;+----------------------+--------------------+| name | dl |+----------------------+--------------------+| rpl_semi_sync_master | semisync_master.so || rpl_semi_sync_slave | semisync_slave.so |+----------------------+--------------------+2 rows in set (0.00 sec) 打开增强半同步复制 12345678910111213141516171819mysql&gt; set global rpl_semi_sync_master_enabled=on;mysql&gt; set global rpl_semi_sync_master_timeout=10000;mysql&gt; set global rpl_semi_sync_slave_enabled=on;root@localhost (none) :51: &gt;show variables like '%semi_sync%';+-------------------------------------------+------------+| Variable_name | Value |+-------------------------------------------+------------+| rpl_semi_sync_master_enabled | ON || rpl_semi_sync_master_timeout | 10000 || rpl_semi_sync_master_trace_level | 32 || rpl_semi_sync_master_wait_for_slave_count | 1 || rpl_semi_sync_master_wait_no_slave | ON || rpl_semi_sync_master_wait_point | AFTER_SYNC || rpl_semi_sync_slave_enabled | ON || rpl_semi_sync_slave_trace_level | 32 |+-------------------------------------------+------------+8 rows in set (0.01 sec) /etc/my.cnf 追加参数： 12345# 这些配置必须在安装插件后才能配置到 my.cnf 文件中，否则会启动失败# 开启增强半同步复制，因为主从节点会发送切换，这里 master 和 slave 都同时打开rpl_semi_sync_slave_enabled=ONrpl_semi_sync_master_enabled=ONrpl_semi_sync_master_timeout=10000 开启主从 Master：node1 Slave：node2，node3 创建复制账号在 Master 节点上创建复制账号 12345# host 需要修改为自己的网络# 指定认证方式 mysql_native_password，不指定默认为 caching_sha2_passwordcreate user 'repluser'@'192.168.3.%' identified with mysql_native_password by 'replpass';grant replication slave,replication client on *.* to 'repluser'@'192.168.3.%'; 如果要在同步复制中使用 caching_sha2_password认证，可以参考官方文档 启动复制 两个 slave 节点分别执行相同的操作 1234567891011# 保证 Slave 为只读状态 mysql&gt; set global read_onln=on;# 配置主节点信息mysql&gt; change master to-&gt; master_host='192.168.3.131',-&gt; master_user='repluser',-&gt; master_password='replpass',-&gt; master_auto_position=1;# 启动复制线程mysql&gt; start slave; 使用 show processlist 命令查看复制连接状态信息： demo >folded12345678mysql&gt; show slave status\\G*************************** 1. row *************************** Slave_IO_State: Waiting for source to send event Slave_IO_Running: Yes Slave_SQL_Running: Yes Slave_SQL_Running_State: Replica has read all relay log; waiting for more updates1 row in set, 1 warning (0.01 sec)# 以上只显示了部分信息 在每个从节点上查看复制账号是否同步过来了，如果同步过来则表示同步配置成功 demo >folded1234567891011root@localhost (none) :06: &gt;select user from mysql.user;+------------------+| user |+------------------+| repluser || mysql.infoschema || mysql.session || mysql.sys || root |+------------------+5 rows in set (0.00 sec) 设置 Master 为可写状态12345678910root@localhost (none) :05: &gt;set global read_only=off;Query OK, 0 rows affected (0.00 sec)root@localhost (none) :09: &gt;select @@read_only;+-------------+| @@read_only |+-------------+| 0 |+-------------+1 row in set (0.00 sec) 一主二从配置完成。","link":"/blog/2024/03/07/Mysql/Mysql%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%20%EF%BC%883%EF%BC%89-%20MYSQL%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"Mysql一主二从 （4）- MHA 安装","text":"MHA 目前在 MYSQL 高可用方面是一个相对成熟的解决方案，是一套在 MYSQL 高可用性环境下进行故障切换和主从提升的优秀软件。在 MYSQL 故障切换的过程中，最大程度地保证数据的完整性和一致性，以达到真正意义上的高可用。接下来本文将描述如何使用 MHA 来搭建一个一主二从的 MYSQL 集群。 工作原理 传统复制： 从宕机崩溃的 Master 保存二进制日记事件（BINLOG event）。 识别含有最新更新的 slave。 应用差异的中继日志（Relay Log）到其他 Slave。 应用从 Master 保存的二进制日志事件。 提升一个 Slave 为新的 Master。 使其他 Slave 连接到新的 Master 进行复制。 GTID 复制模式： 识别含有最新更新的 Slave。 复制差异的 BINLOG 数据到其他 Slave。 提升一个 Slave 为新的 Master。 使其他 Slave 连接到新的 Master 进行复制。 组件MHA Manager >folded12345678masterha_check_ssh：MHA SSH 免密通信环境检测工具masterha_check_repl：Mysql 复制环境检测工具masterha_manager：MHA 服务主程序masterha_check_status：MHA 运行状态检测工具masterha_master_monitor：Mysql master 节点性能检测工具masterha_master_swich：master 节点切换工具masterha_conf_host：添加或者删除配置的节点masterha_stop：关闭 MHA 服务的工具 MHA Node >folded1234save_binary_logs：保存和复制 master 的二进制日志apply_diff_replay_logs：识别差异的中继日志事件并应用到其他 slave 节点filter_mysqlbinlog：去除不必要的 Rollback 事件（MHA 已经不使用这个工具）purge_replay_logs：清楚中继日志（不会阻塞 sql 线程） 自定义扩展 >folded12345secondary_check_script：通过多条网络路由检测 master 的可用性。master_ip_failover_script：检测 application 使用的 masterip。shutdown_script：强制关闭 master 节点。init_conf_load_script：加载初始配置参数。master_ip_online_change_script：更新 master 节点 ip 地址。 使用要点 MHA Manager 可以单独部署在一台服务器，可以同时管理多个 MYSQL 集群。 MHA Manager 也可以部署在其中一台从节点上，但是不能在主节点上，否则一尸两命。 MHA Manager 在进行故障转移后，会停止自身进程，需要运维人员再次启动，如果 MHA Manager 节点被提升为主节点，需要在其他从节点启动 MHA Manager。 MHA Manager 高可用MHA 目前不支持多个 Manager 同时监控一个 MYSQL 主从集群，因此，如果 MHA Manager 宕机，就无法启动主节点的故障转移。但是，MHA Manager 本身不参与业务，因此其单点故障的潜在威胁比较低，唯一需要避免的就是主节点和 MHA Manager 同时宕机。 可以考虑下面两种方法来提高 MHA 的可用性： 对 MHA Manager 进行监控，发生单点故障时能及时通知运维人员进行处理。 可以选择使用 Pacemaker 等常见的主/备作为其高可用方案。 安装 MHA安装 MHA Node 注意：每个节点都需要安装 MHA Node，包括 MHA Manager 1. 安装 epel 源 >folded123[root@node4 ~]# yum install -y epel-release[root@node4 ~]# yum clean all[root@node4 ~]# yum makecache 2. 下载并安装 MHA Node >folded12[root@localhost tmp]# wget -P /tmp https://github.com/yoshinorim/mha4mysql-node/releases/download/v0.58/mha4mysql-node-0.58-0.el7.centos.noarch.rpm[root@node4 ~]# yum install -y /tmp/mha4mysql-node-0.58-0.el7.centos.noarch.rpm 3. 安装完成后会在 /usr/bin 目录生成如下脚本 >folded1234/usr/bin/save_binary_logs #保存和复制 master 的二进制日志/usr/bin/apply_diff_replay_logs #识别差异的中继日志事件并应用到其他 slave 节点/usr/bin/filter_mysqlbinlog #去除不必要的 Rollback 事件（MHA 已经不使用这个工具）/usr/bin/purge_replay_logs #清楚中继日志（不会阻塞 sql 线程） 安装 MHA Manager配置主库1. 在主节点（node1）上创建 mha 的监测账号 >folded123456789# MHA 默认使用 mysql_native_password 认证方式root@localhost (none) :37: &gt;create user 'mhauser'@'192.168.3.%' identified with mysql_native_password by 'mhapass';Query OK, 0 rows affected (0.03 sec)root@localhost (none) :40: &gt;flush privileges;Query OK, 0 rows affected (0.01 sec)root@localhost (none) :40: &gt;grant all privileges on *.* to 'mhauser'@'192.168.3.%';Query OK, 0 rows affected (0.01 sec) 2. 检测账号是否同步完毕 >folded123456789101112131415161718# 由于前面配置了主从复制，因此我们不需要在从节点上重复创建，也一定不要创建（会冲突）[root@localhost tmp]# ssh node2[root@node2 ~]# mysql -uroot -p -e &quot;select user,host from mysql.user where user='mhauser';&quot;Enter password:+---------+-------------+| user | host |+---------+-------------+| mhauser | 192.168.3.% |+---------+-------------+[root@localhost tmp]# ssh node3[root@node3 ~]# mysql -uroot -p -e &quot;select user,host from mysql.user where user='mhauser';&quot;Enter password:+---------+-------------+| user | host |+---------+-------------+| mhauser | 192.168.3.% |+---------+-------------+ 3. 配置主节点的浮动 IP: 192.168.3.200/24 >folded123456789101112[root@localhost tmp]# ip addr add 192.168.3.200/24 dev ens33[root@localhost tmp]# ip addr list ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:ca:2b:a0 brd ff:ff:ff:ff:ff:ff inet 192.168.3.131/24 brd 192.168.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever # 在网络接口 ens33 上新配置的 ip 地址 inet 192.168.3.200/24 scope global secondary ens33 valid_lft forever preferred_lft forever inet6 fe80::25c7:c0dc:4aeb:8e4/64 scope link noprefixroute valid_lft forever preferred_lft forever 配置 MHA Manager 节点 我们选择从节点 node3 部署 MHA Manager 1. 下载 rpm 包并安装 >folded12345# 下载 MHA Manager rpm 包[root@localhost tmp]# wget -P /tmp https://github.com/yoshinorim/mha4mysql-manager/releases/download/v0.58/mha4mysql-manager-0.58-0.el7.centos.noarch.rpm# 安装 MHA Manageryum install -y /tmp/mha4mysql-manager-0.58-0.el7.centos.noarch.rpm 1. 创建 MHA Manager 的配置文件夹 >folded123456[root@node3 ~]# mkdir -pv /etc/masterha# app1 为 MYSQL 集群的名称（任意）[root@node3 ~]# mkdir -pv /data/masterha/app1# 由于 MHA Manager 也有可能在其他从节点运行，因此同样在其他节点也顺便创建配置文件夹[root@node3 ~]# ssh node1 'mkdir -pv /data/masterha/app1'[root@node3 ~]# ssh node2 'mkdir -pv /data/masterha/app1' 3. 创建自动故障转移时的回调脚本`/usr/local/bin/master_ip_failover` >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/usr/bin/env perl# Copyright (C) 2011 DeNA Co.,Ltd.## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation; either version 2 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc.,# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA## Note: This is a sample script and is not complete. Modify the script based on your environment.# 脚本官方样例：https://github.com/yoshinorim/mha4mysql-manager/blob/master/samples/scripts/master_ip_failover，下面脚本是在官方脚本的基础上做的修改，修改的地方有中文注释说明use strict;use warnings FATAL =&gt; 'all';use Getopt::Long;use MHA::DBHelper;my ( $command, $ssh_user, $orig_master_host, $orig_master_ip, $orig_master_port, $new_master_host, $new_master_ip, $new_master_port, $new_master_user, $new_master_password);##### 浮动 ip 配置my $vip = '192.168.3.200/24'; # 修改成你需要的 virtual ip my $net_dev = &quot;ens33&quot;; # 修改成你的网络设备my $ssh_start_vip = &quot;ip addr add $vip dev $net_dev&quot;; my $ssh_stop_vip = &quot;ip addr del $vip dev $net_dev&quot;;GetOptions( 'command=s' =&gt; \\$command, 'ssh_user=s' =&gt; \\$ssh_user, 'orig_master_host=s' =&gt; \\$orig_master_host, 'orig_master_ip=s' =&gt; \\$orig_master_ip, 'orig_master_port=i' =&gt; \\$orig_master_port, 'new_master_host=s' =&gt; \\$new_master_host, 'new_master_ip=s' =&gt; \\$new_master_ip, 'new_master_port=i' =&gt; \\$new_master_port, 'new_master_user=s' =&gt; \\$new_master_user, 'new_master_password=s' =&gt; \\$new_master_password,);exit &amp;main();sub main { if ( $command eq &quot;stop&quot; || $command eq &quot;stopssh&quot; ) { # $orig_master_host, $orig_master_ip, $orig_master_port are passed. # If you manage master ip address at global catalog database, # invalidate orig_master_ip here. my $exit_code = 1; eval { # updating global catalog, etc # 故障转移时，旧 Master 节点的回调处理 print &quot;disabling the vip on old master: $orig_master_host \\n&quot;; &amp;stop_vip(); $exit_code = 0; }; if ($@) { warn &quot;Got Error: $@\\n&quot;; exit $exit_code; } exit $exit_code; } elsif ( $command eq &quot;start&quot; ) { # all arguments are passed. # If you manage master ip address at global catalog database, # activate new_master_ip here. # You can also grant write access (create user, set read_only=0, etc) here. my $exit_code = 10; eval { ## Update master ip on the catalog database, etc ## 故障转移时，新 Master 节点的回调处理 print &quot;Enabling the VIP - $vip on the new master - $new_master_host\\n&quot;; &amp;start_vip(); $exit_code = 0; }; if ($@) { warn $@; # If you want to continue failover, exit 10. exit $exit_code; } exit $exit_code; } elsif ( $command eq &quot;status&quot; ) { # do nothing exit 0; } else { &amp;usage(); exit 1; }}# 启动浮动 IPsub start_vip(){ `ssh $ssh_user\\@$new_master_host \\&quot; $ssh_start_vip \\&quot;`;}# 关闭浮动 IPsub stop_vip(){ `ssh $ssh_user\\@$orig_master_host \\&quot; $ssh_stop_vip \\&quot;`;}sub usage { print&quot;Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\\n&quot;;} 4. 创建 MYSQL 集群的配置文件：`/etc/masterha/app1.cnf` >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344# 服务默认配置[server default]# sshssh_user=rootssh_port=22# mha 工作目录manager_workdir=/data/masterha/app1manager_log=/data/masterha/app1/manager.logremote_workdir=/data/masterha/app1## Mysql# mha manager 用例管理其他 mysql 服务的超级权限账号user=mhauserpassword=mhapass# 复制账号repl_user=repluserrepl_password=replpass# mha 监控心跳周期ping_interval=1ping_type=connect# 自动 failover 时候的切换脚本master_ip_failover_script=/usr/local/bin/master_ip_failover# 手动切换时候的切换脚本master_ip_online_change_script=/usr/local/bin/master_ip_online_change# 故障转移后发送告警通知脚本report_script=/usr/local/bin/send_report# 一旦 mha 到 node1 的监控之间网络出现了问题，mha manager 将会尝试从 node2 登录到 node1secondary_check_script=/usr/bin/masterha_secondary_check -s node2 --user=root --master_host=node1 --master_ip=192.168.3.131 --master_port=3306# 故障发送后关闭故障主机脚本，防止发生脑裂shutdown_script=&quot;&quot;[server1]hostname=node1candidate_master=1[server2]hostname=node2candidate_master=1[server3]hostname=node3candidate_master=1 启动 MHA Manager1. 检测集群 SSH 互通状态 >folded123456789101112131415161718192021[root@node3 ~]# masterha_check_ssh --conf=/etc/masterha/app1.cnfThu Feb 29 18:33:15 2024 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Thu Feb 29 18:33:15 2024 - [info] Reading application default configuration from /etc/masterha/app1.cnf..Thu Feb 29 18:33:15 2024 - [info] Reading server configuration from /etc/masterha/app1.cnf..Thu Feb 29 18:33:15 2024 - [info] Starting SSH connection tests..Thu Feb 29 18:33:16 2024 - [debug]Thu Feb 29 18:33:15 2024 - [debug] Connecting via SSH from root@node1(192.168.3.131:22) to root@node2(192.168.3.132:22)..Thu Feb 29 18:33:16 2024 - [debug] ok.Thu Feb 29 18:33:16 2024 - [debug] Connecting via SSH from root@node1(192.168.3.131:22) to root@node3(192.168.3.133:22)..Thu Feb 29 18:33:16 2024 - [debug] ok.Thu Feb 29 18:33:17 2024 - [debug]Thu Feb 29 18:33:15 2024 - [debug] Connecting via SSH from root@node2(192.168.3.132:22) to root@node1(192.168.3.131:22)..Thu Feb 29 18:33:16 2024 - [debug] ok.Thu Feb 29 18:33:16 2024 - [debug] Connecting via SSH from root@node2(192.168.3.132:22) to root@node3(192.168.3.133:22)..Thu Feb 29 18:33:17 2024 - [debug] ok.Thu Feb 29 18:33:17 2024 - [debug]Thu Feb 29 18:33:16 2024 - [debug] Connecting via SSH from root@node3(192.168.3.133:22) to root@node1(192.168.3.131:22)..Thu Feb 29 18:33:17 2024 - [debug] ok.Thu Feb 29 18:33:17 2024 - [debug] Connecting via SSH from root@node3(192.168.3.133:22) to root@node2(192.168.3.132:22)..Thu Feb 29 18:33:17 2024 - [debug] ok.Thu Feb 29 18:33:17 2024 - [info] All SSH connection tests passed successfully. 2. 检测集群同步状态 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@node3 ~]# masterha_check_repl --conf=/etc/masterha/app1.cnfThu Feb 29 19:39:17 2024 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Thu Feb 29 19:39:17 2024 - [info] Reading application default configuration from /etc/masterha/app1.cnf..Thu Feb 29 19:39:17 2024 - [info] Reading server configuration from /etc/masterha/app1.cnf..Thu Feb 29 19:39:17 2024 - [info] MHA::MasterMonitor version 0.58.Thu Feb 29 19:39:18 2024 - [info] GTID failover mode = 1Thu Feb 29 19:39:18 2024 - [info] Dead Servers:Thu Feb 29 19:39:18 2024 - [info] Alive Servers:Thu Feb 29 19:39:18 2024 - [info] node1(192.168.3.131:3306)Thu Feb 29 19:39:18 2024 - [info] node2(192.168.3.132:3306)Thu Feb 29 19:39:18 2024 - [info] node3(192.168.3.133:3306)Thu Feb 29 19:39:18 2024 - [info] Alive Slaves:Thu Feb 29 19:39:18 2024 - [info] node2(192.168.3.132:3306) Version=8.0.27 (oldest major version between slaves) log-bin:enabledThu Feb 29 19:39:18 2024 - [info] GTID ONThu Feb 29 19:39:18 2024 - [info] Replicating from 192.168.3.131(192.168.3.131:3306)Thu Feb 29 19:39:18 2024 - [info] Primary candidate for the new Master (candidate_master is set)Thu Feb 29 19:39:18 2024 - [info] node3(192.168.3.133:3306) Version=8.0.27 (oldest major version between slaves) log-bin:enabledThu Feb 29 19:39:18 2024 - [info] GTID ONThu Feb 29 19:39:18 2024 - [info] Replicating from 192.168.3.131(192.168.3.131:3306)Thu Feb 29 19:39:18 2024 - [info] Primary candidate for the new Master (candidate_master is set)Thu Feb 29 19:39:18 2024 - [info] Current Alive Master: node1(192.168.3.131:3306)Thu Feb 29 19:39:18 2024 - [info] Checking slave configurations..Thu Feb 29 19:39:18 2024 - [info] Checking replication filtering settings..Thu Feb 29 19:39:18 2024 - [info] binlog_do_db= , binlog_ignore_db=Thu Feb 29 19:39:18 2024 - [info] Replication filtering check ok.Thu Feb 29 19:39:18 2024 - [info] GTID (with auto-pos) is supported. Skipping all SSH and Node package checking.Thu Feb 29 19:39:18 2024 - [info] Checking SSH publickey authentication settings on the current master..Thu Feb 29 19:39:18 2024 - [info] HealthCheck: SSH to node1 is reachable.Thu Feb 29 19:39:18 2024 - [info]node1(192.168.3.131:3306) (current master) +--node2(192.168.3.132:3306) +--node3(192.168.3.133:3306)Thu Feb 29 19:39:18 2024 - [info] Checking replication health on node2..Thu Feb 29 19:39:18 2024 - [info] ok.Thu Feb 29 19:39:18 2024 - [info] Checking replication health on node3..Thu Feb 29 19:39:18 2024 - [info] ok.Thu Feb 29 19:39:18 2024 - [info] Checking master_ip_failover_script status:Thu Feb 29 19:39:18 2024 - [info] /usr/local/bin/master_ip_failover --command=status --ssh_user=root --orig_master_host=node1 --orig_master_ip=192.168.3.131 --orig_master_port=3306Thu Feb 29 19:39:19 2024 - [info] OK.Thu Feb 29 19:39:19 2024 - [warning] shutdown_script is not defined.Thu Feb 29 19:39:19 2024 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK. 3. 启动 >folded123[root@node3 ~]# nohup masterha_manager --conf=/etc/masterha/app1.cnf --ignore_last_failove &lt; /dev/null &gt;/data/masterha/app1/manager.log 2&gt;&amp;1 &amp;[1] 15176[root@node3 ~]# 4. 查看启动状态 >folded1234567891011121314151617181920212223242526272829303132333435363738394041[root@node3 ~]# tail -f /data/masterha/app1/manager.logFri Mar 1 01:42:36 2024 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Mar 1 01:42:36 2024 - [info] Reading application default configuration from /etc/masterha/app1.cnf..Fri Mar 1 01:42:36 2024 - [info] Reading server configuration from /etc/masterha/app1.cnf..Fri Mar 1 01:42:36 2024 - [info] MHA::MasterMonitor version 0.58.Fri Mar 1 01:42:37 2024 - [info] GTID failover mode = 1Fri Mar 1 01:42:37 2024 - [info] Dead Servers:Fri Mar 1 01:42:37 2024 - [info] Alive Servers:Fri Mar 1 01:42:37 2024 - [info] node1(192.168.3.131:3306)Fri Mar 1 01:42:37 2024 - [info] node2(192.168.3.132:3306)Fri Mar 1 01:42:37 2024 - [info] node3(192.168.3.133:3306)Fri Mar 1 01:42:37 2024 - [info] Alive Slaves:Fri Mar 1 01:42:37 2024 - [info] node2(192.168.3.132:3306) Version=8.0.27 (oldest major version between slaves) log-bin:enabledFri Mar 1 01:42:37 2024 - [info] GTID ONFri Mar 1 01:42:37 2024 - [info] Replicating from 192.168.3.131(192.168.3.131:3306)Fri Mar 1 01:42:37 2024 - [info] Primary candidate for the new Master (candidate_master is set)Fri Mar 1 01:42:37 2024 - [info] node3(192.168.3.133:3306) Version=8.0.27 (oldest major version between slaves) log-bin:enabledFri Mar 1 01:42:37 2024 - [info] GTID ONFri Mar 1 01:42:37 2024 - [info] Replicating from 192.168.3.131(192.168.3.131:3306)Fri Mar 1 01:42:37 2024 - [info] Primary candidate for the new Master (candidate_master is set)Fri Mar 1 01:42:37 2024 - [info] Current Alive Master: node1(192.168.3.131:3306)Fri Mar 1 01:42:37 2024 - [info] Checking slave configurations..Fri Mar 1 01:42:37 2024 - [info] Checking replication filtering settings..Fri Mar 1 01:42:37 2024 - [info] binlog_do_db= , binlog_ignore_db=Fri Mar 1 01:42:37 2024 - [info] Replication filtering check ok.Fri Mar 1 01:42:37 2024 - [info] GTID (with auto-pos) is supported. Skipping all SSH and Node package checking.Fri Mar 1 01:42:37 2024 - [info] Checking SSH publickey authentication settings on the current master..Fri Mar 1 01:42:37 2024 - [info] HealthCheck: SSH to node1 is reachable.Fri Mar 1 01:42:37 2024 - [info]node1(192.168.3.131:3306) (current master) +--node2(192.168.3.132:3306) +--node3(192.168.3.133:3306)Fri Mar 1 01:42:37 2024 - [info] Checking master_ip_failover_script status:Fri Mar 1 01:42:37 2024 - [info] /usr/local/bin/master_ip_failover --command=status --ssh_user=root --orig_master_host=node1 --orig_master_ip=192.168.3.131 --orig_master_port=3306Fri Mar 1 01:42:37 2024 - [info] OK.Fri Mar 1 01:42:37 2024 - [warning] shutdown_script is not defined.Fri Mar 1 01:42:37 2024 - [info] Set master ping interval 1 seconds.Fri Mar 1 01:42:37 2024 - [info] Set secondary check script: /usr/bin/masterha_secondary_check -s node2 --user=root --master_host=node1 --master_ip=192.168.3.131 --master_port=3306Fri Mar 1 01:42:37 2024 - [info] Starting ping health check on node1(192.168.3.131:3306)..Fri Mar 1 01:42:37 2024 - [info] Ping(CONNECT) succeeded, waiting until MySQL doesn't respond.. 模拟故障转移1. 在 windows 主机通过浮动 IP 登录并查看 server_id >folded1234567D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -p -h 192.168.3.200 -e &quot;select @@server_id;&quot;Enter password: *******+-------------+| @@server_id |+-------------+| 1 |+-------------+ 2. 停掉当前主节点（node1）上的 MYSQL 实例 >folded1234567891011121314151617181920# 停止 mysql 实例[root@localhost tmp]# systemctl stop mysqld[root@localhost tmp]# systemctl status mysqld● mysqld.service - LSB: start and stop MySQL Loaded: loaded (/etc/rc.d/init.d/mysqld; bad; vendor preset: disabled) Active: inactive (dead) since 五 2024-03-01 01:44:15 CST; 5s ago Docs: man:systemd-sysv-generator(8) Process: 47061 ExecStop=/etc/rc.d/init.d/mysqld stop (code=exited, status=0/SUCCESS) Process: 45134 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)# 查看 ip 地址状态[root@localhost tmp]# ip addr list ens33# 浮动 ip &quot;192.168.3.200/24&quot; 已经被转移2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:ca:2b:a0 brd ff:ff:ff:ff:ff:ff inet 192.168.3.131/24 brd 192.168.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::25c7:c0dc:4aeb:8e4/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost tmp]# 3. 再次在 windows 主机通过浮动 IP 登录并查看 server_id >folded12345678D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -p -h 192.168.3.200 -e &quot;select @@server_id;&quot;Enter password: *******# server_id 已经由 1 变成了 2，也就说明了 node2 成为了新的主节点，并且浮动 IP 也已经转移到 node2。+-------------+| @@server_id |+-------------+| 2 |+-------------+ 4. 查看 node3 的主从状态 >folded1234567891011121314root@localhost (none) :58: &gt;show slave status\\G*************************** 1. row *************************** Slave_IO_State: Waiting for source to send event Master_Host: 192.168.3.132 # 主节点也已经切换到 node2 Master_User: repluser Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000003 Read_Master_Log_Pos: 2264 Relay_Log_File: node3-relay-bin.000002 Relay_Log_Pos: 418 Relay_Master_Log_File: mysql-bin.000003 Slave_IO_Running: Yes Slave_SQL_Running: Yes MHA Manager 故障转移成功，并且整个过程对于 Client 端都是透明的。 模拟故障恢复下面再用一个简单的情景模拟一下 MHA 故障转移和故障恢复，已经其是否能保障数据的完整性。 故障转移：1. 在主节点创建一张 student 表 >folded1234root@localhost (none) :52: &gt;create database test;Query OK, 1 row affected (0.04 sec)root@localhost (none) :52: &gt;create table test.student( studentId int primary key, name varchar(50), age int);Query OK, 0 rows affected (0.07 sec) 2. Client 端使用 10 条线程插入 10w 条数据 >folded12345678910111213141516171819202122232425262728293031323334353637383940// 插入采用重试策略，插入返回失败会继续重试到成功为止@SpringBootApplicationpublic class MHADemo implements ApplicationListener&lt;ApplicationReadyEvent&gt; { @Autowired JdbcTemplate jdbcTemplate; public static void main(String[] args) { SpringApplication.run(MHADemo.class,args); } @Override public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) { for(int i=1;i&lt;=10;i++){ // 每条线程插入 1w 条数据 new Thread(task(i),&quot;Thread-&quot;+i).start(); } } private Runnable task(final int threadId){ return ()-&gt;{ for(int studentId = threadId;studentId &lt;=100_000;studentId+=10){ Map&lt;String,String&gt; student = new HashMap&lt;&gt;(); student.put(&quot;studentId&quot;,studentId + &quot;&quot;); student.put(&quot;name&quot;,&quot;name-&quot;+studentId); student.put(&quot;age&quot;,(studentId % 100)+&quot;&quot;); while (true) { try { jdbcTemplate.update(&quot;insert into test.student (studentId,name,age) values(?,?,?)&quot;, student.get(&quot;studentId&quot;), student.get(&quot;name&quot;), student.get(&quot;age&quot;)); System.out.printf(&quot;[Thread-%s]: insert studentId: %s\\n&quot;,threadId,studentId); break; } catch (Exception e) { System.err.printf(&quot;[Thread-%s]: insert failed, studentId: %s\\n&quot;,threadId,studentId); } } } System.out.printf(&quot;[Thread-%s]: insert completed\\n&quot;,threadId); }; }} 3. 在插入的过程中关闭主节点的 MYSQL 实例，此时 Client 端会插入失败，并且不断重试。 >folded1 4. MHA 故障转移成功，Client 重试成功，继续完成后面的数据插入。 >folded1 5. 查询 node2 和 node3 的数据完整性 >folded1234567891011121314151617181920212223# 都有全部 10w 条数据[root@node1 ~]# ssh node2Last login: Thu Feb 29 18:50:37 2024 from node1[root@node2 ~]# mysql -uroot -p -e 'select count(*) from test.student;'Enter password:+----------+| count(*) |+----------+| 100000 |+----------+[root@node2 ~]# exit;登出Connection to node2 closed.[root@node1 ~]# ssh node3Last login: Thu Feb 29 18:52:20 2024 from node1[root@node3 ~]# mysql -uroot -p -e 'select count(*) from test.student;'Enter password:+----------+| count(*) |+----------+| 100000 |+----------+ 5. 查询 node1 的数据 >folded123456789# node1 只有故障前的部分数据[root@node1 ~]# systemctl start mysqld[root@node1 ~]# mysql -uroot -p -e 'select count(*) from test.student;';Enter password:+----------+| count(*) |+----------+| 31189 |+----------+ 故障回复：1. 重新启动 node1 >folded1&lt;!--code￼0--&gt; 2. 把 node1 设置为 node2 的从节点加入集群 >folded12345678910111213141516171819202122232425262728293031root@localhost (none) :17: &gt;stop slave;Query OK, 0 rows affected, 2 warnings (0.00 sec)root@localhost (none) :17: &gt;reset slave;Query OK, 0 rows affected, 1 warning (0.00 sec)root@localhost (none) :17: &gt;change master to-&gt; master_host='192.168.3.132', -&gt; master_user='repluser', -&gt; master_password='replpass', -&gt; master_auto_position=1;Query OK, 0 rows affected, 7 warnings (0.06 sec)root@localhost (none) :18: &gt;start slave;Query OK, 0 rows affected, 1 warning (0.04 sec)root@localhost (none) :18: &gt;show slave status\\G*************************** 1. row *************************** Slave_IO_State: Waiting for source to send event Master_Host: 192.168.3.132 Master_User: repluser Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000009 Read_Master_Log_Pos: 40520183 Relay_Log_File: node1-relay-bin.000002 Relay_Log_Pos: 2527803 Relay_Master_Log_File: mysql-bin.000009 Slave_IO_Running: Yes Slave_SQL_Running: Yes1 row in set, 1 warning (0.01 sec) 3. node1 成功从新的主节点上复制剩余的数据： >folded1234567891011121314151617181920212223root@localhost (none) :18: &gt;select count(*) from test.student;+----------+| count(*) |+----------+| 53421 |+----------+1 row in set (0.01 sec)root@localhost (none) :18: &gt;select count(*) from test.student;+----------+| count(*) |+----------+| 66588 |+----------+1 row in set (0.00 sec)root@localhost (none) :19: &gt;select count(*) from test.student;+----------+| count(*) |+----------+| 100000 |+----------+1 row in set (0.00 sec) 4. 修改 `/etc/masterha/app1.cnf` 的 `secondary_check_script` 参数 >folded12# 修改为 master_host=node2， master_ip=192.168.3.132， -s node1secondary_check_script=/usr/bin/masterha_secondary_check -s node1 --user=root --master_host=node2 --master_ip=192.168.3.132 --master_port=3306 5. 重新启动 MHA Manager >folded12345678# 启动前先检测集群的复制状态[root@node3 ~]# masterha_check_repl --conf=/etc/masterha/app1.cnf...MySQL Replication Health is OK.# 启动[root@node3 ~]# nohup masterha_manager --conf=/etc/masterha/app1.cnf --ignore_last_failove &lt; /dev/null &gt;/data/masterha/app1/manager.log 2&gt;&amp;1 &amp;[1] 19535[root@node3 ~]# 参考资料《深入浅出 MYSQL》 《MHA Manager Github》","link":"/blog/2024/03/07/Mysql/Mysql%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%20%EF%BC%884%EF%BC%89-%20MHA%20%E5%AE%89%E8%A3%85/"},{"title":"Keepalived + LVS-DR 高可用负载均衡器搭建","text":"","link":"/blog/2024/03/05/Linux/LVS/Keepalived%20+%20LVS-DR%20%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"title":"Mysql一主二从 （6）- 读写分离","text":"","link":"/blog/2024/03/07/Mysql/Mysql%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%20%EF%BC%886%EF%BC%89-%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"},{"title":"LVS 负载均衡器搭建","text":"本文将通过虚拟机环境，描述如果一步步搭建一个简单标准的 LVS 负载均衡器，包括 LVS-DR 和 LVS-NAT 两种网络模型。 LVS-DR部署图 VMware 在创建虚拟网络是会自动创建虚拟交换机，上图中的三台虚拟机通过虚拟交换机链接在同一个 VMnet。 搭建虚拟机环境参考文章《VMware 安装 Centos 7》 搭建三个虚拟机节点： director，real1 和 real2。 三个节点的网络适配器都选择桥接模式。 Director Server1. 配置 DIP: 192.168.3.130 >folded1234567891011121314151617181920212223[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static # 静态DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=e0abc9ba-44a4-4570-b0bd-b7ee3e519bac DEVICE=ens33IPADDR=192.168.3.130 # DIP：192.168.3.130 NETMASK=255.255.255.0 # 子掩码GATEWAY=192.168.3.1 # 网关 DNS1=192.168.3.1 ONBOOT=yes # 开机自动加载# 重启网络服务[root@director ~]# systemctl restart network 2. 配置 VIP: 192.168.3.10 >folded12[root@director ~]# ip addr add 192.168.3.10/32 broadcast 192.168.3.10 dev ens33[root@director ~]# ip route add 192.168.3.10 via 192.168.3.10 dev ens33 3. 安装 ipvsadm >folded1[root@director ~]# yum -y install ipvsadm 4. 添加 ipvs 规则 >folded1234567891011[root@director ~]# ipvsadm -A -t 192.168.3.10:80 -s rr[root@director ~]# ipvsadm -a -t 192.168.3.10:80 -r 192.168.3.131 -g -w 1[root@director ~]# ipvsadm -a -t 192.168.3.10:80 -r 192.168.3.132 -g -w 1[root@director ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.3.10:80 rr -&gt; 192.168.3.131:80 Route 1 0 0 -&gt; 192.168.3.132:80 Route 1 0 0[root@director ~]# Real Server 分别对两个 Real Server 进行同样的配置 1. 配置 RIP1: 192.168.3.131 >folded12345678910111213141516171819202122232425vi /etc/sysconfig/network-scripts/ifcfg-ens33TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static # 修改为静态DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=8b0071db-3302-5df1-a61b-4542df285eb2DEVICE=ens33IPADDR=192.168.3.131 # RIP1NETMASK=255.255.255.0 # 子网掩码GATEWAY=192.168.3.1 # 网关 DNS1=192.168.3.1 ONBOOT=yes # 修改启动自动加载# 重启网络服务[root@director ~]# systemctl restart network 2. 配置 VIP (noarp): 192.168.3.10 >folded12345678910111213141516171819202122# 防止其他网络接口通过 arp 暴露 lo 上的 VIP[root@real1 cdrom]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore [root@real1 cdrom]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce # 配置 VIP[root@real1 cdrom]# ip addr add 192.168.3.10/32 broadcast 192.168.3.10 dev lo label lo:0[root@real1 cdrom]# ip route add 192.168.3.10 via 192.168.3.10 dev lo:0[root@real1 cdrom]# ip addr list lo1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever # VIP inet 192.168.3.10/32 brd 192.168.3.10 scope global lo:0 valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever# 路由信息[root@real1 cdrom]# ip route showdefault via 192.168.3.1 dev ens33 proto static metric 100192.168.3.0/24 dev ens33 proto kernel scope link src 192.168.3.131 metric 100192.168.3.10 via 192.168.3.10 dev lo 3. 安装 httpd： >folded123456789# 安装 httpdyum -y install httpd# 创建首页echo &quot;&lt;h1&gt;I am Real Server 1&lt;/h1&gt;&quot; &gt; /var/www/html/index.html# 启动 httpd systemctl start htppd# 访问首页[root@real1 cdrom]# curl localhost&lt;h1&gt;I am real server 1&lt;/h1&gt; 验证负载均衡效果1. 分别关闭 Director Server 和 两个 Real Server的 防火墙 >folded12[root@director ~]# systemctl stop firewalld[root@director ~]# systemctl disable firewalld 2. 多次请求 VIP:80 效果 >folded123456789101112# 浏览器的 Http 连接是设置了 Keep-Alived 的长连接，因此 rr 的负载均衡的演示效果不够明显，因为多次刷新可能使用的都是同一条连接。C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt; I am real server 2&lt;/h1&gt;C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt;I am real server 1&lt;/h1&gt;C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt; I am real server 2&lt;/h1&gt;C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt;I am real server 1&lt;/h1&gt; LVS-NAT部署图 注意：LVS-NAT 模型下 VIP/DIP 是一组浮动 IP，当主 Director 宕机时，它们需要同时转移到备 Direcotr 上，而 LVS-DR 模型下只需要转移 VIP 即可。 搭建虚拟机环境 注意：我们修改虚拟机配置的时候，最好先关闭虚拟机 我们继续使用上面 LVS-DR 的三个节点：director，real1 和 real2。 修改网络拓扑： director 网络适配器-》网络连接-》桥接模式（和上面 LVS-DR 小节的配置一样） director 节点额外添加一个网络适配器2：编辑虚拟机设置-》添加-》网络适配器-》完成。 director 网络适配器2-》网络连接-》自定义-》VMnet2 real1 网络适配器-》网络连接-》自定义-》VMnet2 real2 网络适配器-》网络连接-》自定义-》VMnet2 Director Server1. 查看网络接口名称 >folded123456789[root@director ~]# ip link show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00# 网络适配器2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:cf:dc:08 brd ff:ff:ff:ff:ff:ff# 网络适配器23: ens38: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:cf:dc:12 brd ff:ff:ff:ff:ff:ff 2. 配置 DIP: 192.168.4.1 >folded12# 在 lvs-nat 模型下 dip 也是浮动 ip [root@director ~]# ip addr add 192.168.4.1/24 broadcast 192.168.4.255 dev ens38 3. 配置 VIP: 192.168.3.10 >folded12[root@director ~]# ip addr add 192.168.3.10/32 broadcast 192.168.3.10 dev ens33[root@director ~]# ip route add 192.168.3.10/32 via 192.168.3.10 dev ens33 4. 打开 ipv4 转发 >folded1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 5. 配置 IPVS 规则 >folded12345678910111213141516# 清除 ipvs 规则[root@director ~]# ipvsadm -C# 添加 ipvs 规则[root@director ~]# ipvsadm -A -t 192.168.3.10:80 -s rr# 添加两个 Real Server nat模式 权重为1[root@director ~]# ipvsadm -a -t 192.168.3.10:80 -r 192.168.4.101 -m -w 1[root@director ~]# ipvsadm -a -t 192.168.3.10:80 -r 192.168.4.102 -m -w 1# 查看 ipvs 规则[root@director ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.3.10:80 rr -&gt; 192.168.4.101:80 Masq 1 0 0 -&gt; 192.168.4.102:80 Real Server 分别对两个 Real Server 进行同样的配置 1. 配置 RIP: 192.168.4.101 >folded1234567891011121314151617181920212223vi /etc/sysconfig/network-scripts/ifcfg-ens33TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static # 修改为静态DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=02497b7f-4f6c-4ac4-a0cd-0c435f1c6898DEVICE=ens33IPADDR=192.168.4.101 # RIP1NETMASK=255.255.255.0 # 子网掩码GATEWAY=192.168.4.1 # 网关必须指向 Directoer 的 DIPONBOOT=yes # 修改启动自动加载# 重启网络服务[root@real1 ~]# systemctl restart network 注意：此时 Real Server 和你的宿主机不在同一个网段，因此可能无法使用 ssh 终端进行登录，一个的方法是使用 director 作为跳板，先使用终端登录 director，再通过 ssh 命令登录 real server。 验证负载均衡效果多次请求 VIP:80 效果 >folded123456789101112# 浏览器的 Http 连接是设置了 Keep-Alived 的长连接，因此 rr 的负载均衡的演示效果不够明显，因为多次刷新可能使用的都是同一条连接。C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt; I am real server 2&lt;/h1&gt;C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt;I am real server 1&lt;/h1&gt;C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt; I am real server 2&lt;/h1&gt;C:\\Windows\\system32&gt;curl http://192.168.3.10&lt;h1&gt;I am real server 1&lt;/h1&gt; 如何离线安装 Httpd在 LVS-NAT 模式下直接使用 yum 源安装 Httpd 可能遇到失败的情况，因为此时 Real Server 不能访问外网。 一个方式是使用 ISO 镜像作为本地的 yum 源： 1. 先备份 Base 源 >folded1[root@real2 ~]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 2. 修改 etc/yum.repos.d/CentOS-Media.repo 文件，如果没有则手动创建 >folded12345678[c7-media]name=CentOS-$releasever - Mediabaseurl=file:///media/CentOS/ file:///media/cdrom/ file:///media/cdrecorder/gpgcheck=1enabled=1 # 该参数默认值为 0，修改为 1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 3. 挂载镜像 >folded123[root@real2 ~]# mkdir /media/cdrom[root@real2 ~]# mount -r /dev/cdrom /media/cdrom[root@real2 ~]# cd /cdrom 4. 重新加载 yum 缓存 >folded12[root@real2 ~]# yum clean all[root@real2 ~]# yum makecache 5. 安装 httpd >folded1[root@real2 cdrom]# yum -y install httpd 参考资料LVS 官方文档 LVS-HOWTO","link":"/blog/2024/03/04/Linux/LVS/LVS%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"title":"LVS-简介","text":"LVS（Linux Virtual Server）是建立在真实服务器集群基础上的高可扩展性和高可用性虚拟服务器，整个真实服务集群系统对终端用户而言就好像只是一台高性能的虚拟服务器。 LVS 可用于构建 Linux 高性能的负载均衡服务器集群，使集群的并行服务以虚拟服务的形式出现在单个 IP 地址上，请求分派使用 IP 负载平衡技术。系统的可扩展性是通过在集群中透明地添加或删除节点来实现的。通过检测节点或守护进程故障并适当地重新配置系统，可提供高可用性。 关键词 Director Server：负载均衡节点 RealServer：处理请求的真实服务节点 VIP：Virtule IP，主要用于外网通信 DIP：Director IP，主要用于内网通信 RIP：Real IP，RealServer 的 IP 地址 CIP：Client IP，外网客户端 IP LVS 工作模式 LVS-NAT LVS-DR(direct routint) LVS-TUN(ip tunnelling) LVS-FULLNET LVS-NAT通过 NAT 虚拟服务器的优点是，真实服务器可以运行任何支持 TCP/IP 协议的操作系统，真实服务器可以使用专用互联网地址，负载平衡器只需要一个 IP 地址。 缺点是通过 NAT 虚拟服务器的可扩展性有限。当服务器节点（一般 PC 服务器）增加到 20 个左右或更多时，负载平衡器可能会成为整个系统的瓶颈，因为请求数据包和响应数据包都需要由负载平衡器重写。 LVS-NAT 一些需要注意的点 RIP 应该和 DIP 应该使用私网地址。 RIP 和 DIP必须在同一IP网络，且 Real Server 的网关需要指向 DIP。 请求和响应报文都要经由 director 转发，极高负载的场景中，director 可能会成为系统瓶颈。 支持端口映射，VIP 和 RIP 不需要监听在同一端口。 Real Server 可以使用任意OS。 客户端请求（src：CIP，dest：VIP:80） LVS 调度和重写数据包并将数据包通过 DIP 发送到 Real Server（src：CIP，dest：RIP1:80） Real Server1 接受并处理请求 Real Server1 回复 DIP（src：RIP1:80，dest：CIP） DIP 接受数据后将数据包的源地址和端口修改为 VIP:80 并转发到 VIP （src：VIP:80，des：CIP） VIP 将数据返回到 CIP（src：VIP:80，des：CIP） LVS-DRDR 模式相对于 NAT 来说有着更好的负载能力，因为它只需要处理连接的请求数据，而回复则由真实服务器直接返回给客户端。 DR 模式对网络拓扑有以下要求： DR 模式是通过修改 MAC 地址来进行直接转发，因此 Director Server 和 Real Server 必须有一个接口通过 HUB/交换机进行物理连接。 Diretor Server 和 Real Server 都同时拥有 VIP，前者使用 VIP 接受请求，后者则需要使用 VIP 进行回复。 Diretor Server 的 VIP 必须暴露给路由器，而 Real Server 的 RIP 则必须被隐藏，否则将会出现 IP 冲突。 Director Server 和 Real Server 至少存在一个物理网口连接在同一个集线器/交互机上。 下面是一个简单LVS-DR负载均衡的网络模型： 客户端向 VIP:Port 发送请求报文。 由于只有 Direcotr 的 VIP 暴露给了路由，因此路由将请求报文的目标 MAC 指向了 Director。 交互机将请求报文转发给 Director。 Directory 接受请求报文，IPVS 会在 netfilter 中进行拦截，发现和 IPVS 规则匹配，因此根据调度算法选择一台 Real Server 进行转发：将请求报文的目标 MAC 修改为该 Real Server 的MAC，并重新转发给交换机。 交换机将请求报文转发给 Real Server。 Real Server 接受并解析请求报文，发现目标地址为 VIP，因此转发给 lo:0 进行处理，并使用 VIP 作为源地址对客户端直接进行回复。 交换机将回复报文转发给路由器 路由器将回复报文转发给客户端。 上面网络拓扑 Real Server 可以直接回复 Client 是因为 VIP 和 RIP 同处一个网段，并且 RIP 的网关指向了图中的路由器。 LVS 组件ipvsipvs 工作在 Linux 内核中的 netfilter INPUT 钩子上，支持 TCP，UPD，AH，EST，AH_EST，SCTP 等诸多协议。 一个 ipvs 主机可以同时定义多个 cluster service 一个 cluster service 上至少有一个 real service 定义时可以指明 lvs-type，缺省为 dr 定义时可以指明lvs scheduler，缺省为 wlc rr：轮询 wrr：加权轮询 lc：最少连接 wlc：加权最少连接 lblc：基于局部性的最少链接调度 lblcr：带复制的基于局部性最少链接调度 dh：目标地址散列调度 sh：源地址散列调度 ipvsadmipvsadm 是一个用户空间的命令行工具，用于管理集群服务。 管理 Director Server添加一个 Director Server 12345# ipvsadm 添加 tcp 192.168.3.10:80 调度算法 轮询ipvsadm -A -t 192.168.3.10:80 -s rr# ipvsadm 添加 udp 192.168.3.2:5000 调度算法 加权最少连接数ipvsadm -A -u 192.168.3.2:5000 -s wlc 修改一个 Director Server 12# ipvsadm 修改 tcp 192.168.3.10:80 调度算法 加权轮询ipvsadm -E -t 192.168.3.10:80 -s wrr 删除一个 Director Server 1ipvsadm -D -t 192.168.3.100:80 管理 Real Server：添加一个 Real Server 1234567# ipvsadm 添加 tcp director server real server dr 权重 1ipvsadm -a -t 192.168.3.10:80 -r 192.168.3.101:8080 -g -w 1ipvsadm -a -t 192.168.3.10:80 -r 192.168.3.102:80 -g -w 1# ipvsadm 添加 udp director server real server nat 权重 2ipvsadm -a -u 192.168.3.2:5000 -r 192.168.3.103:5000 -m -w 2ipvsadm -a -u 192.168.3.2:5000 -r 192.168.3.104:5001 -m -w 1 查看和清空查看 ipvs 规则： 123456789101112# -L：列出所有 ipvs 规则# -n：地址和端口通过数字显示[root@node4 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.3.10:80 wrr -&gt; 192.168.3.101:80 Route 1 0 0 -&gt; 192.168.3.102:80 Route 1 0 0UDP 192.168.3.2:5000 wlc -&gt; 192.168.3.103:5000 Masq 2 0 0 -&gt; 192.168.3.104:5001 Masq 1 0 0 清空 ipvs 规则 1ipvsadm -C 保存和恢复保存 ipvs 规则到指定文件： 12345678[root@node4 ~]# ipvsadm-save -n &gt; /etc/sysconfig/ipvsadm-config[root@node4 ~]# cat /etc/sysconfig/ipvsadm-config-A -t 192.168.3.10:80 -s wrr-a -t 192.168.3.10:80 -r 192.168.3.101:80 -g -w 1-a -t 192.168.3.10:80 -r 192.168.3.102:80 -g -w 1-A -u 192.168.3.2:5000 -s wlc-a -u 192.168.3.2:5000 -r 192.168.3.103:5000 -m -w 2-a -u 192.168.3.2:5000 -r 192.168.3.104:5001 -m -w 1 恢复 ipvs 规则： 12345678910111213141516171819# 清空 ipvs 规则[root@node4 ~]# ipvsadm -C[root@node4 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn[root@node4 ~]## 恢复 ipvs 规则[root@node4 ~]# ipvsadm-restore &lt; /etc/sysconfig/ipvsadm-config[root@node4 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.3.10:80 wrr -&gt; 192.168.3.101:80 Route 1 0 0 -&gt; 192.168.3.102:80 Route 1 0 0UDP 192.168.3.2:5000 wlc -&gt; 192.168.3.103:5000 Masq 2 0 0 -&gt; 192.168.3.104:5001 Masq 1 0 0 参考资料LVS 官方文档 LVS-HOWTO","link":"/blog/2024/03/03/Linux/LVS/LVS-%E7%AE%80%E4%BB%8B/"},{"title":"双指针（一）","text":"双指针是一种简单而又灵活的技巧和思想，单独使用可以轻松解决一些特定问题，和其他算法结合也能发挥多样的用处。双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。双指针本身的思想并不难，但是并不代表它很容易掌握，双指针的问题重点不在于你如何使用它，而是如何能“嗅到”该用它了。能用双指针解决的问题，数据往往都带有一些的特性质，比如单调性或者区间收敛，对这些数据的敏感度才是掌握双指针的关键，但不是每个人都是数学大神，对于这种情况“记录和总结”应该算是比较好的抢救方法了。 滑动窗口滑动窗口是双指针最经典的用法之一，通常对数组保存一对下标，然后根据实际情况交替推进两个端点直到得出答案。 例题：POJ 3061 subsequence给定长度为 n 的数列 a_0,a_1,a_2...a_n-1 以及整数 S，求出总和不少于 S 的连续子数组的长度的最小值，如果不存在则输出 0。解题思路：子区间求和，第一时间就是想到前缀和 ，因此对于每个 我们只需要求出满足 的最小的 就行了。由于 前缀和具有单调性质，因此可以考虑使用二分来解决，这样时间复杂度是 。 我们先来考虑一下最暴力的解法： 123456789int ans=0;for(int i=0;i&lt;n;++i){ for(int j=i+1;j&lt;=n;++j){ if(sum[j]&gt;=sum[i]+S){ ans=max(ans,j-i); break; } }} 这是一个 的方法，我们观察上面的代码可以发现 S 是不变的，而 是单调不减的，因此如果一个区间 [j1,j2] 在 i 的情况下不满足要求，那么在 i + 1 下也肯定不满足要求，因此我们可考虑使用两个指针在一个 for 循环上来维护 i 和 j 的位置，因为对于被 i 淘汰的 j 来说，i + 1 是不需要再回去遍历它们的。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n,s,a[N];int main(){ int T; for(scanf(\"%d\",&amp;T);T&gt;0;--T){ scanf(\"%d %d\",&amp;n,&amp;s); int ans=n+1; for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;a[i]); for(int l=0,r=0,t=0;;){ while(r&lt;n&amp;&amp;t&lt;s) t+=a[r++]; if(t&lt;s)break; ans=min(ans,r-l); t-=a[l++]; } if(ans&gt;n) ans=0; printf(\"%d\\n\",ans); }} 例题：leetcode 3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。思路分析：这是一种非常常见的滑动窗口面试题，通过统计区间的元素的个数来维持区间的某种性质，让其交替前进。 我们还是不妨先来考虑暴力枚举，我们枚举每一个结束字符的所有子区间，然后判断是否符合不包含重复字符的要求，然后取最大长度的那一个区间。 123456789for(int j=0;j&lt;s.size();++j){ memset(cnt,0,sizefo(cnt)); for(int i=j;i&gt;=0;--i){ if(cnt[s[i]]++==1) tot++;//如果当前字符之前已经存在第一个，那么重复字符个数 + 1 if(tot==0){//表示没有重复字符 ans=max(ans,j-i+1); } }} 上面算法的时间复杂度是 ，我们可以发现有很多重复的统计，对于字符串 “abcabcbb”，当我们统计以第一个 c 为结尾的子区间的时候，会统计abc 的个数，当我们统计以第二个a为结尾的子区间的时候，abc 的个数还会被重新统计，但是其实我们可以重复利用前面的统计。我们可以使用两个指针 i 和 j 来维护一个区间，让区间在每次迭代后都满足重复个数等于 0 条件即可。 123456789101112131415class Solution {public: int lengthOfLongestSubstring(string s) { vector&lt;int&gt; cnt(256,0); int l,r,ans=0,tot=0; for(l=0,r=0;r&lt;s.size();++r){ if(cnt[s[r]]++==1) tot++; while(tot){ if(--cnt[s[l++]]==1) tot--; } ans=max(ans,r-l+1); } return ans; }}; leetcode 567. 字符串的排列 leetcode 30. 串联所有单词的子串 例题：leetcode 220. 存在重复元素 III给你一个整数数组 和两个整数 和 。请你判断是否存在 两个不同下标 和 ，使得 ，同时又满足 。 思路分析： 这种类型的滑动窗口长度是固定，所以推进是比较简单，但是往往会结合一些数据结构，比如堆、单调队列或者有序集合等。典型问题是的动态查询每个区间的第 n 大值，或者是否存在满足条件的元素。 就这题而言，我们可以枚举每个 ，因此问题就变成了在下标区间 范围内是否存在一个数 ，其满足 ，可以使用一个有序集合（比如平衡树）来维护当前窗口除 以外的所有数，我们通过查找第一个大于等于 的数 ，判断 是否满足上面的条件即可。 1234567891011121314class Solution {public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) { set&lt;long long&gt; st; int n=nums.size(),l,r; for(l=0,r=0;r&lt;n;++r){ auto it=st.lower_bound((long long)nums[r]-t); if(it!=st.end()&amp;&amp;*it&lt;=(long long)nums[r]+t) return true; st.insert(nums[r]); if(r&gt;=k) st.erase(nums[l++]); } return false; }}; 例题：leetcode 480. 滑动窗口中位数给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数（如果 k 为偶数，中位数为中间两个数的平均值），并输出由它们组成的数组。 思路分析： 和上面的题目一样，都是长度是固定的滑动窗口问题。我们可以通过两个堆来维护第 k/2 大值，左边 [0,k/2) 为大顶堆，右边 [k/2,k] 为小顶堆，因此我们只需要通过两个堆的堆顶即可得到中位数。 首先初始化一个长度为 k 的窗口，并且获取第一个中位数。 窗口往右边滑动一个数，就把该数压入堆顶，如果右边的堆为空，或者该数比右边堆顶要大，则压入右边，否则左边。 窗口左边出一个数，如果该数大于等于右边堆顶，则从右边堆顶删除，否则从左边删除。 维护两边堆的个数，如果左边个数小于 k/2，则把右边的堆顶弹出压入左边，如果左边个数大于 k/2，则把左边的堆顶弹出压入右边。 获取中位数 循环第 2 - 5 步。 由于需要删除堆元素，因此需要自定义实现一个懒删除堆。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071typedef long long LL;class PQ { private: priority_queue&lt;LL&gt; pq; unordered_map&lt;LL,int&gt; delayed; int delCnt=0; private: void prune(){ while(pq.size()&amp;&amp;delayed.count(pq.top())){ int c=--delayed[pq.top()]; if(c==0) delayed.erase(pq.top()); pq.pop(); delCnt--; } } public: int size(){ return pq.size() - delCnt; } LL top(){ prune(); LL res=pq.top(); return res; } LL pop(){ LL res=top(); pq.pop(); return res; } void push(LL x){ pq.push(x); } void del(LL x){ delayed[x]++; delCnt++; }};class Solution {public: PQ L; //大顶堆 PQ R; //通过存入相反数来模拟小顶堆 double getMedian(int k){ if(k&amp;1) return -R.top(); return ((double)L.top()-R.top())/2; } vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int l,r,n=nums.size(); vector&lt;double&gt; ans(n-k+1,0); //初始化第一个长度为 k 的窗口 for(l=0,r=0;r&lt;k;++r) R.push(-(LL)nums[r]); for(int i=0;i&lt;k/2;++i) L.push(-R.pop()); int cur=0; ans[cur++]=getMedian(k); //不断向右滑动 for(;r&lt;n;++r,++l){ int a=nums[l], b=nums[r]; if(R.size()==0 ||b&gt;=-R.top()) R.push(-(LL)b); else L.push(b); if(a&gt;=-R.top()) R.del(-(LL)a); else L.del(a); while(L.size()&lt;k/2) L.push(-R.pop()); while(L.size()&gt;k/2) R.push(-L.pop()); ans[cur++]=getMedian(k); } return ans; }}; 例题：leetcode 424. 替换后的最长重复字符你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。在执行上述操作后，返回包含相同字母的最长子字符串的长度。 思路分析： 对于区间 需要满足 ，其中 是不需要改变的字母数量，由于 是常量，因此 越大， 的值也就可以越大。因此在遍历的过程中我们只需要关注最大的 就行。当 向右移动变成 后，如果 不变，那么区间会变为 ，如果 增大了，那一次只会增大 ，这时候区间变为 ，最后 滑到最右边的时候，最后的区间长度一定等于最优的长度。 如果题目要求最长字串的内容，那么不能取最后的区间字串，需要取最大 cnt 的第一次出现的区间字串。 123456789101112class Solution {public: int characterReplacement(string s, int k) { vector&lt;int&gt; cnt(256,0); int l,r,mx=0,n=s.size(); for(l=0,r=0;r&lt;n;r++){ mx=max(mx,++cnt[s[r]]); // r 向右移动一个字符 if(r-l+1-mx&gt;k) --cnt[s[l++]];//如果 mx 没有改变 l++ } return r-l; }}; leetcode 2024. 考试的最大困扰度 例题：leetcode 992. K 个不同整数的子数组给定一个正整数数组 和一个整数 ，返回 中「好子数组」 的数目。如果 的某个子数组中不同整数的个数恰好为 ，则称 的这个子数组为 「好子数组 」。 参考思路： 我们可以枚举每一个子数组的最后一个元素，下标设为 ，同时设 为子数组的不同整数的数目，对于任意一个 ，如果存在一个区间 满足 ，那么一定有 和 ，因此满足 r 的所有左端点都在区间 [l1,l2] 这连续区间内，同时 [l1,l2] 的所有点也都可以作为 r 的左端点。但是那样我们需要求出每个 r 的 [l1,l2]，时间复杂度是 。 由于我们只需要求子数组的个数，所以我们可以维护两个区间 和 ，那么对于右端点 来说满足要求的左端点个数就是 。 是第一个满足 的左端点，而 ，是第一个满足 的左端点。 1234567891011121314151617181920class Solution {public: int subarraysWithKDistinct(vector&lt;int&gt;&amp; nums, int k) { int n=nums.size(); map&lt;int,int&gt; cnt1,cnt2; int l1=0,l2=0,r=0,t1=0,t2=0,ans=0,a=0; for(;r&lt;n;++r){ if(++cnt1[nums[r]]==1) t1++; if(++cnt2[nums[r]]==1) t2++; while(t1&gt;k) { if(--cnt1[nums[l1++]]==0) t1--; } while(t2&gt;k-1){ if(--cnt2[nums[l2++]]==0) t2--; } ans+=l2-l1; } return ans; }}; 例题：leetcode 167. 两数之和 II - 输入有序数组给你一个下标从 1 开始的非递减整数数组 numbers ，请你从数组中找出满足相加之和等于目标数 target 的两个数。你可以假设每个输入只对应一个答案。 1234567891011121314151617class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int i,j,n=numbers.size(); vector&lt;int&gt; ans; for(i=0,j=n-1;i&lt;j;){ if(numbers[i]+numbers[j]==target) { ans.push_back(i+1); ans.push_back(j+1); break; } if(i&lt;j&amp;&amp;numbers[i]+numbers[j]&gt;target) --j; if(i&lt;j&amp;&amp;numbers[i]+numbers[j]&lt;target) ++i; } return ans; }}; 例题：leetcode 11. 盛最多水的容器给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。 12345678910111213class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int n=height.size(); int ans=0; for(int i=0,j=n-1;i&lt;j;){ ans=max(ans,(j-i)*min(height[i],height[j])); if(height[i]&lt;height[j]) ++i; else --j; } return ans; }}; 参考资料《挑战程序设计竞赛》 《算法竞赛入门经典》 《leetcode》 《oi-wiki》","link":"/blog/2024/02/05/algorithm/double_point/"},{"title":"Mysql一主二从 （5）- 负载均衡","text":"对于大公司来说往往都有着专门的负载均衡服务器，但是对于一些小规模的项目来说“一锅炖”也是常有的事情，接下来本文将描述如果在两台真实服务器上，基于 Keepalived + LVS/DR 搭建一个高可用的负载均衡器。 LVS 简介如果想了解 LVS/DR 的工作原理可以参考文章：《LVS-简介》 如果想了解如何基于 Keepalived 部署一个最小化的标准 LVS/DR 负载均衡集群，可以参考文章：《LVS 负载均衡器搭建》，《Keepalived + LVS-DR 高可用负载均衡器搭建》 部署 Keepalived + LVS/DR 的主备负载均衡集群部署图 这里无法直接套用文章《Keepalived + LVS-DR 高可用负载均衡器搭建》中的配置，因为上述图中只有三台机器，因此一个节点上会同时存在 Director Server 和 Real Server，这种情况下需要解决一个额外的问题： LVS 备用节点存在 IPVS 规则时会产生流量转发的死循环问题。 流量转移死循环问题为什么会产生流量转发的死循环？我们可以假设这么一种情景：存在两台互为主备的 LVS-DR 节点，并且它们同时也是 Real Server。 Client 向 VIP:Port 发送请求，由于只有 LVS Master 节点上的 VIP 是对外暴露的，因此该请求会被转发到 LVS Master 节点上。 LVS Master 节点接收数据后，会首先由 IPVS 进行处理，IPVS 根据规则选择一个 Real Server 进行转发，假如选择了 Real Server2。 LVS Backup节点接收数据后， 由于其上面也存在 IPVS 规则，因此 IPVS 也会根据规则选择一个 Real Server 进行转发，假如选择了 Real Server1。 LVS Master 节点再次接收到同一个连接的数据后，IPVS 会根据缓存表直接将数据再次转发给 Real Server2。 LVS Backup 节点再次接收到同一个连接的数据后，IPVS 同样也会根据缓存表直接将数据再次转发给 Real Server1。 最终形成了死循环，当请求流量大时，不断形成的死循环会形成流量风暴，导致网络接口不能正常工作。 在当前场景中，我是通过 Keepalived 来实现 LVS 的高可用，而 Keepalived 不管主/备都会生成 IPVS 规则，这有利于快速进行故障转移，但是也会造成上述的死循环问题。 解决死循环问题容易想到的两个思路是： LVS Backup 节点上不加载 IPVS 规则，只有转为主节点时才加载 IPVS 规则。 想办法识别 LVS Master 转发过的流量，并让 LVS 不处理这种流量。 动态加载 IPVS 规则先来了解三个 keepalived 的配置参数： 参数 作用 notify_master 当前节点切换为主节点时，执行指定的脚本 notify_backup 当前节点切换为备节点时，执行指定的脚本 notify_fault 当前节点切换为故障状态时，执行指定的脚本 因此可以借助通知脚本来实现该功能： 指定 notify_master 执行脚本，并通过其加载 IPVS 规则。 指定 notify_backup 和 notify_fault，并通过其清空当前 IPVS 规则。 这种方式思路非常简单，但也会有一些问题： 动态加载 IPVS 规则增加了主备切换的时间成本。 虽然 Keepalived 内置了对 LVS 的支持，但是 LVS 本身和 Keepalived 并不是一个组件，因此如果 Keepalived Master 被意外杀死而没有调用通知脚本，此时当 Keepalived Backup 转为 Master 状态时，就会再次出现死循环问题。 使用 iptables + lvs fwmarklvs fwmark 功能可以对被 iptables 标记的流量进行识别，因此假如我们有两个 LVS 节点 node1 和 node2： 在 node1 上配置 iptable 规则： 12# 如果请求 VIP:Port 的流量的源 MAC 地址不等于 node2 MAC 地址，则表明该流量为客户端请求流量，并将其 mark 值设置为 1。iptables -t mangle -I PREROUTING -d $VIP -p tcp --dport $VPORT -m mac ! --mac-source $MAC_NODE2 -j MARK --set-mark 0x1 在 node2 配置 iptable 规则 12# 如果请求 VIP:Port 的流量的源 MAC 地址不等于 node1 MAC 地址，则表明该流量为客户端请求流量，并将其 mark 值设置为 1。iptables -t mangle -I PREROUTING -d $VIP -p tcp --dport $VPORT -m mac ! --mac-source $MAC_NODE1 -j MARK --set-mark 0x1 keepalived 上配置 lvs fwmark： 123456virtual_server fwmark 1 { delay_loop 10 lb_algo rr lb_kind DR ....} 这种方式需要利用 iptables 规则，但是可以允许主/备 LVS 同时存在 IPVS 规则，这里我也是选择了这种解决方案。 Real Server 配置 三台节点都需要同样的配置 设置隐藏 VIP: 192.168.3.100 >folded123456# 设置 vip 到 lo 网口ip addr add 192.168.3.100/32 broadcast 192.168.3.100 dev loip route add 192.168.3.100/32 via 192.168.3.100 dev lo# 防止 lo 上地址被其他网口通过 arp 广播暴露出去echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignoreecho 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce LVS 主节点配置（node2）1. 安装 keepalived >folded1yum install -y keepalived 2. 配置 /etc/keepalived/keepalived.conf >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172global_defs { notification_email { xxxxx@163.com yyyyy@163.com } notification_email_from lvs_node1@domain.com smtp_server 192.168.3.20 smtp_connect_timeout 30 router_id node2 # 修改为当前节点名称 script_user root enable_script_security}#VIP 配置vrrp_instance VI_1 { state BACKUP # 采用 Backup -&gt; Backup 的非抢占模式 nopreempt # 非抢占模式 interface ens33 # vip 所在网络接口 virtual_router_id 3 priority 150 # 优先级 advert_int 1 authentication { auth_type AH auth_pass k@l!ve1 } # 虚拟ip 地址 virtual_ipaddress { 192.168.3.10 } # 通知脚本 notify_master &quot;/etc/keepalived/notify.sh master&quot; notify_backup &quot;/etc/keepalived/notify.sh backup&quot; notify_fault &quot;/etc/keepalived/notify.sh fault&quot;}# 健康监测 和 LVS 负载均衡virtual_server fwmark 1 { delay_loop 3 # 监控检测间隔 lb_kind DR # 负载均衡的转发模式 # 下面配置为 rr 和 0 是因为测试效果明显，能明显看到每次请求都分发到不同服务器 lb_algo rr # 负载均衡算法 persistence_timeout 0 #会话保持时间 protocol TCP #真实服务器 real_server 192.168.3.131 3306 { weight 1 # 这里只做简单的健康检测 TCP_CHECK { connect_timeout 3 } } real_server 192.168.3.132 3306 { weight 1 TCP_CHECK { connect_timeout 3 } } real_server 192.168.3.133 3306 { weight 1 TCP_CHECK { connect_timeout 3 } }} 3. 设置 iptalbes 规则： >folded12345678910111213# ping 一下 RIP3ping 192.168.3.133# 获取 node3 的 mac 地址[root@node2 ~]# arp -a 192.168.3.133node3 (192.168.3.133) at 00:0c:29:e9:27:55 [ether] on ens33# 设置 iptables 规则：vip：192.168.3.10 [root@node2 ~]# iptables -t mangle -I PREROUTING -d 192.168.3.10 -p tcp --dport 3306 -m mac ! --mac-source 00:0c:29:e9:27:55 -j MARK --set-mark 0x1[root@node2 ~]# iptables -t mangle -L -nChain PREROUTING (policy ACCEPT)target prot opt source destinationMARK tcp -- 0.0.0.0/0 192.168.3.10 tcp dpt:3306 MAC ! 00:0C:29:E9:27:55 MARK set 0x1 LVS 备节点配置（node3）1. 安装 keepalived >folded1yum install -y keepalived 2. 配置 /etc/keepalived/keepalived.conf >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172global_defs { notification_email { xxxxx@163.com yyyyy@163.com } notification_email_from lvs_node1@domain.com smtp_server 192.168.3.20 smtp_connect_timeout 30 router_id node3 # 修改为当前节点名称 script_user root enable_script_security}#VIP 配置vrrp_instance VI_1 { state BACKUP nopreempt interface ens33 virtual_router_id 3 priority 120 ###### node3 优先级 比 node2 低 advert_int 1 authentication { auth_type AH auth_pass k@l!ve1 } # 虚拟ip 地址 virtual_ipaddress { 192.168.3.10 } # 通知脚本 notify_master &quot;/etc/keepalived/notify.sh master&quot; notify_backup &quot;/etc/keepalived/notify.sh backup&quot; notify_fault &quot;/etc/keepalived/notify.sh fault&quot;}# 健康监测 和 LVS 负载均衡virtual_server fwmark 1 { delay_loop 3 # 监控检测间隔 lb_kind DR # 负载均衡的转发模式 # 下面配置为 rr 和 0 是因为测试效果明显，能明显看到每次请求都分发到不同服务器 lb_algo rr # 负载均衡算法 persistence_timeout 0 #会话保持时间 protocol TCP #真实服务器 real_server 192.168.3.131 3306 { weight 1 # 这里只做简单的健康检测 TCP_CHECK { connect_timeout 3 } } real_server 192.168.3.132 3306 { weight 1 TCP_CHECK { connect_timeout 3 } } real_server 192.168.3.133 3306 { weight 1 TCP_CHECK { connect_timeout 3 } }} 3. 设置 iptalbes 规则： >folded12345678910111213# ping 一下 RIP2ping 192.168.3.132# 获取 node2 的 mac 地址[root@node3 ~]# arp -a 192.168.3.132node2 (192.168.3.132) at 00:0c:29:3b:63:ce [ether] on ens33# 设置 iptables 规则：vip：192.168.3.10 [root@node3 ~]# iptables -t mangle -I PREROUTING -d 192.168.3.10 -p tcp --dport 3306 -m mac ! --mac-source 00:0c:29:3b:63:ce -j MARK --set-mark 0x1[root@node3 ~]# iptables -t mangle -L -nChain PREROUTING (policy ACCEPT)target prot opt source destinationMARK tcp -- 0.0.0.0/0 192.168.3.10 tcp dpt:3306 MAC ! 00:0C:29:3B:63:CE MARK set 0x1 验证1. 启动 keepalived >folded1[root@node2 ~]# systemctl start keepalived; ssh node3 'systemctl start keepalived' 2. 通过远程主机访问 VIP:3306 >folded1234567891011121314151617181920212223D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -pmhapass -h 192.168.3.10 -e &quot;show variables like 'server_id';&quot;mysql: [Warning] Using a password on the command line interface can be insecure.+---------------+-------+| Variable_name | Value |+---------------+-------+| server_id | 3 |+---------------+-------+D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -pmhapass -h 192.168.3.10 -e &quot;show variables like 'server_id';&quot;mysql: [Warning] Using a password on the command line interface can be insecure.+---------------+-------+| Variable_name | Value |+---------------+-------+| server_id | 2 |+---------------+-------+D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -pmhapass -h 192.168.3.10 -e &quot;show variables like 'server_id';&quot;mysql: [Warning] Using a password on the command line interface can be insecure.+---------------+-------+| Variable_name | Value |+---------------+-------+| server_id | 1 |+---------------+-------+ 3. 关闭 node2 上的 keepalived >folded12345678910[root@node2 ~]# systemctl stop keepalived[root@node2 ~]# ip addr list ens33# VIP 已经发送转移2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:3b:63:ce brd ff:ff:ff:ff:ff:ff inet 192.168.3.132/24 brd 192.168.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::74a3:7d4f:d23c:4b03/64 scope link noprefixroute valid_lft forever preferred_lft forever 4. 查看 node3 上的 vip： >folded12345678910[root@node3 ~]# ip addr list ens33# VIP 已经别 node3 持有2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:e9:27:55 brd ff:ff:ff:ff:ff:ff inet 192.168.3.133/24 brd 192.168.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.3.10/32 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::811d:2f59:9e85:f5c4/64 scope link noprefixroute valid_lft forever preferred_lft forever 5. 通过远程主机访问 VIP:3306 >folded1234567891011121314151617181920212223D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -pmhapass -h 192.168.3.10 -e &quot;show variables like 'server_id';&quot;mysql: [Warning] Using a password on the command line interface can be insecure.+---------------+-------+| Variable_name | Value |+---------------+-------+| server_id | 3 |+---------------+-------+D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -pmhapass -h 192.168.3.10 -e &quot;show variables like 'server_id';&quot;mysql: [Warning] Using a password on the command line interface can be insecure.+---------------+-------+| Variable_name | Value |+---------------+-------+| server_id | 2 |+---------------+-------+D:\\Works\\mysql-8.0.15-winx64\\bin&gt;mysql -umhauser -pmhapass -h 192.168.3.10 -e &quot;show variables like 'server_id';&quot;mysql: [Warning] Using a password on the command line interface can be insecure.+---------------+-------+| Variable_name | Value |+---------------+-------+| server_id | 1 |+---------------+-------+ 参考资料LVS 官方文档 LVS-HOWTO Keepalived用户指南","link":"/blog/2024/03/07/Mysql/Mysql%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%20%EF%BC%885%EF%BC%89-%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}],"tags":[{"name":"Mysql","slug":"Mysql","link":"/blog/tags/Mysql/"},{"name":"Linux","slug":"Linux","link":"/blog/tags/Linux/"},{"name":"LVS","slug":"LVS","link":"/blog/tags/LVS/"},{"name":"Load Balancer","slug":"Load-Balancer","link":"/blog/tags/Load-Balancer/"}],"categories":[{"name":"算法","slug":"算法","link":"/blog/categories/%E7%AE%97%E6%B3%95/"},{"name":"Mysql","slug":"Mysql","link":"/blog/categories/Mysql/"}],"pages":[{"title":"about","text":"","link":"/blog/about/index.html"}]}