{"posts":[{"title":"二分","text":"查找值这是二分搜索最简单的用法，在有序的数组中查找某个值是否存在或者最接近某个值的值。 C++ STL 实现了二分查找值的算法，可以直接使用 123456789101112131415161718192021222324//返回第一个大于或者等于 x 的下标，如果不存在则返回 nint i=lower_bound(a,a+n,x) - a;//返回第一个大于或者等于 x 的迭代器，如果不存在则返回尾迭代器。auto it=lower_bound(a.begin(),a.end(),x);//返回第一个大于 x 的下标，如果不存在则返回 nint i=upper_bound(a,a+n,x) - a;//返回第一个大于或者等于 x 的迭代器，如果不存在则返回尾迭代器。auto it=upper_bound(a.begin(),a.end(),x);//注意： 如果是 set 和 map 这种关联式容器，使用上面的两个方法的时间复杂度是 O(n)，需要使用容器自带的方法，时间复杂度为 O(logn)。auto it=s.lower_bound(x);//快速找出有序数组 a 中 x 的数量。int cnt=upper_bound(a,a+n,x) - lower_bound(a,a+n,x);int cnt=upper_bound(a.begin(),a.end(),x) - lower_bound(a.begin(),a.end(),x);//有序数组 a 中 小于 x 的数量int cnt=lower_bound(a,a+n,x) - a;int cnt=lower_bound(a.begin(),a.end(),x) - a.begin();//有序数组 a 中 小于等于 x 的数量int cnt=upper_bound(a,a+n,x) - a;int cnt=upper_bound(a.begin(),a.end(),x) - a.begin(); 假定判断假定判断就是先假定一个解并且判断是否可行，在二分中使用也是非常的频繁，例如求解最大化或者最小化问题。 例题：POJ 1064 Cable master 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;const int N=10010;int n,k;double L[N];int calc(double len){ int res=0; for(int i=0;i&lt;n;++i) res+=(int)(L[i]/len); return res;}//标签：二分 求最大值 实数二分// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d\",&amp;n,&amp;k); for(int i=0;i&lt;n;++i){ scanf(\"%lf\",&amp;L[i]); } double l=0,r=100010; //100 次循环精度可以达到 10^-30，基本上是没有问题的 for(int i=0;i&lt;100;i++){ double md=(l+r)/2; if(calc(md)&gt;=k) l=md; else r=md; } printf(\"%.2f\\n\",floor(r*100)/100); return 0;} 最大化最小值例题：POJ 2456 Aggressive cows 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt; #include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N=100010;int n, c,x[N];bool check(int k,int cnt){ cnt--; for(int i=1,j=0;i&lt;n&amp;&amp;cnt;i++){ if(x[i]-x[j]&gt;=k){ j=i; cnt--; } } return cnt==0;}//标签：二分 最大值最小// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d\",&amp;n,&amp;c); for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;x[i]); sort(x,x+n); int l=0,r=x[n-1]-x[0]; while(l&lt;=r){ int md=l+(r-l)/2; if(check(md,c)) l=md+1; else r=md-1; } printf(\"%d\\n\",r);} 最大化最小值或者最小化最大值 经常也会带有一定的贪心算法在里面，通常借助排序或者优先队列来建立判断条件。 最大化平均值例题：有 n 个物品的重量和价值分别是 wi 和 vi。从中选出 k 个物品使得单位重量的价值最大。 限制条件： 1&lt;=k&lt;=n&lt;1000；1&lt;=wi,vi&lt;=1000000 样例： 输入：n=3；k=2；(w,v)={(2,2),(5,3),(2,1)} 输出：0.75 (选择 0 号和 2 号物品，(2+1)/(2+2)=0.75) 解题思路： 一般最先想到的方法是按照单位价值进行排序，从大到小贪心地进行选择，但是这种方法对于上面的例子的结果是 0.714，所以这种方式不可行。 我们可以使用二分解决这个问题，假定判断条件： 可以通过选择使得单位价值不小于那么原问题就变成了求满足 C(x) 的最大的 x。假设我们选择的集合是 s，因此它们的单位价值是： 把上面不等式进行变形： 因此可以对的值进行排序，然后贪心地进行选取： 从大到小前个和不小于 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;using namespace std;const int MAX_N = 10010;int n, k;int w[MAX_N], v[MAX_N];double y[MAX_N], INF;//判断是否满足条件bool C(double x){ for (int i = 0; i &lt; n; ++i){ y[i] = v[i] - w[i] * x; } sort(y, y + n); //计算最大的 K 个 yi 的和 double sum = 0; for (int i = 0; i &lt; k; ++i){ sum += y[n - 1 - i]; } return sum &gt;= 0;}void solve(){ double l = 0, r = INF; for (int i = 0; i &lt; 100; ++i){ double md = (l + r) / 2; if (C(md)) l = md; else r = md; } printf(\"%.2f\\n\", l); 查找第 K 个值如果是有序序列（比如：数组），我们可以直接读取第 k 个值，但是有时候我们并不能高效地定位到第 k 个值，或者第 K 个值是动态的，比如二维矩阵、动态查询等，这时候我们可以尝试考虑二分查找。 利用二分来查找第 k 个值，一般基于这么一个判断：设定一个值 x，如果 x 小于第 k 个值，那么小于等于 x 的个数一定小于 k；反过来如果 x 大于等于第 k 个值，那么小于等于 x 的个数一定不小于 k，这其实就是一个假定判断，因此这种方法的核心就是计数。 ps ：在有序的序列中，upper_bound 和 lower_bound 能非常方便的计算小于某个值的个数。 例题：leetcode 668. 乘法表中第k小的数 几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？乘法表是大小为 m x n 的一个整数矩阵，其中 mat[i][j] == i * j（下标从 1 开始）。给你三个整数 m、n 和 k，请你在大小为 m x n 的乘法表中，找出并返回第 k 小的数字。 参考思路：就是使用上面的判断方法来进行二分，关键是计数,由于，因此，可知每一行小于等于 x 的个数为。 12345678910111213141516171819202122class Solution {public: int findKthNumber(int m, int n, int k) { if(m&gt;n) swap(m,n); int l=1; int r=9e8; while(l&lt;=r){ int mid=l + (r-l)/2; if(calc(m,n,mid)&lt;k) l=mid+1; else r=mid-1; } return l; } int calc(int m, int n,int mid){ int res=0; for(int i=1;i&lt;=m;++i){ res+=n*i&lt;=mid?n:mid/i; } return res; }}; 最小（大）化第 K 值例题：POJ 2010 Moo University - Financial Aid“ 农场新建了一所奶牛大学，想从一共 头牛中招收 头牛作为学生（，而且 是奇数），每头牛都有一个如下前的考试分数 和一个需要补助的学费 。但是目前大学总的补助经费只有 ，因此不能随意招收任意的奶牛。现在你是招生办主任，你要在不超过补助经费 的情况下，从 头牛中选 头录取，并且分数中位数最大。 思路分析： 由于N是奇数，因此就是让第 N/2 + 1 高的分数最大，怎么办？我们可以先考虑最暴力的解法，求出所有的符合条件的 N头牛的不同组合，然后对比这些组合中第 N/2 + 1 高的分数，那个最大。但是组合数太大了，而且如果我们把每个组合的分数排序然后取第 N/2 + 1 个分数，那总的时间复杂度需要​ 如果我们像上面那样使用二分来取第 K 大值呢，好像时间复杂度还是 O(NlogN)，但是它可以使用一些贪心算法，我们没必要比对每个组合。我们回忆一下上面求第 K 大值的方法，我们根据当前小于等于 x 的个数 count 来决定 x 是该增大还是减少，假如 count 小于 K，那么 x 就可以增大。那么回到当前，如果这些组合里面至少存在一个组合的 count 比 K 小，那么 x 就可以增大了，换句话说只要存在有 count 比 K 小，x 就可以增大，那么我们是不是可以只和最小的 count 比就行了。那么我们如何让比 x 小的个数尽量少呢？在经费不超过 F 的情况下，尽量选分数比 x 大就行。但是需要额外先判断是否存在解，只有一定存在解才进入二分的逻辑，可以避免特殊边界的判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAX_C=100010;int N,C,F,L[MAX_C],R[MAX_C];struct cow{ int c,f;}cows[MAX_C];int cmp(const cow&amp; a, const cow&amp; b){ return a.c&lt;b.c;}// 标签：二分 最小化第 K 大的值 int calc(int x){ for(int i=0;i&lt;C;++i){ L[i]=cows[i].f; } int i,j,l,r; for(i=0,l=0,r=0;i&lt;C;++i){ if(cows[i].c&lt;=x) L[l++]=cows[i].f; else R[r++]=cows[i].f; } int res=0; sort(L,L+l);//分数小于等于 x 的奶牛的补助放到一个数组，称为左边 sort(R,R+r);//分数比 x 大的奶牛的补助放到一个数组，称为右边 LL s=0,cnt=0; for(i=0;cnt&lt;N&amp;&amp;i&lt;r;++i) s+=R[i],++cnt;//优先右边选，并且从小往大选，这样能选尽量多。 j=i; for(i=0;i&lt;l&amp;&amp;cnt&lt;N;++i) s+=L[i],++cnt;//如果右边的奶牛总算不够 N 头，从左边补够N头。 for(;i&lt;l&amp;&amp;s&gt;F;++i) s+=L[i]-R[--j];//如果总的补助大于 F，那么把右边最大替换掉，再用左边较小的替换。 res=i;//左边一共选择了多少头，就是有多个分数小于等于 x。 return res;}// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d %d\",&amp;N,&amp;C,&amp;F); for(int i=0;i&lt;C;++i){ scanf(\"%d %d\",&amp;cows[i].c,&amp;cows[i].f); L[i]=cows[i].f; } sort(L,L+C); LL s=0; int ans=-1; for(int i=0;i&lt;N;++i) s+=L[i]; //判断是否无解，如果无解不需要二分 if(s&lt;=F){ sort(cows,cows+C,cmp); int l=0,r=C-1,k=N/2+1; while(l&lt;=r){ int md=(l+r)/2; if(calc(cows[md].c)&lt;k) l=md+1; else r=md-1; } ans=cows[l].c; } printf(\"%d\\n\",ans); return 0;} 例题：POJ 3662 Telephone Lines FJ 想在电话公司和自己的农场之间建立电话线路，它们之间有 n 根电线杆，1 和 n 号电线杆分别在电话公司和农场内，这些电线杆之间有的可以相互连接(a,b,l 表示a 和 b 连接的费用是 l)，有的不行。电话公司愿意支付 k 根最贵的电话线，剩下的电话线中最贵的一根的费用就是 FJ 需要支付的最终费用。求 FJ 可以建立电话线路需要的最小费用。 解题思路：这是一张无向图，如果 1 和 n 之间非连通，则返回 -1，如果连通需要的最少边数小于等于 k 则费用是0，如果边数大于 k ，则第 k+1 贵的电线就是 FJ 要支付的费用，因此问题就是最小化第 k+1大的值。 连通性和连通的最少边数可以使用 BFS 求出，这个非常简单，问题是如何才能最小化第 K+1 大的值。不妨先想办法找出每条路径第 k+1 大的值，然后取它们中的最小值，总体上的思路和上面 POJ 2010 类似，使用二分 + 贪心。我们依然使用 x 来判断，如果大于等于 x 的边数 count 少于 k+1，那么说明 x 还可以更小，因此我们只需要和最小的 count 比就行。我们设大于等于 x 的边权为 1，其他为 0，那么最小的 count 就是最短路径，可以使用 dijkstra 算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int P=20100; // 要记得向前星无向边的容量是边数的两倍const int N=1010;int n,p,k,d[N],e[P];priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt;&gt; pq; //小根堆struct Edge{ int to, w,next;}edges[P];int id,head[P];void add(int u, int v, int w){ edges[++id].to=v; edges[id].next=head[u]; edges[id].w=w; head[u]=id;}int djk(int x){ memset(d,-1,sizeof(d)); while(pq.size()) pq.pop(); //这里一定要注意清空队列 d[1]=0; pq.push(make_pair(0,1)); while(pq.size()){ pi t=pq.top(); pq.pop(); int w=t.first, u=t.second; if(u==n) break; if(d[u]!=-1&amp;&amp;d[u]&lt;w) continue; for(int i=head[u];i;i=edges[i].next){ int v=edges[i].to; if(d[v]==-1||(d[v]&gt;d[u]+(edges[i].w&gt;=x))){ d[v]=d[u] + (edges[i].w&gt;=x); pq.push(make_pair(d[v],v)); } } } return d[n];}//#define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d %d %d\",&amp;n,&amp;p,&amp;k); int u,v,w; for(int i=0;i&lt;p;++i){ scanf(\"%d %d %d\",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); e[i]=w; } int mik=djk(0); if(mik&lt;0) printf(\"%d\\n\",-1); else if(mik&lt;=k) printf(\"%d\\n\",0); else { sort(e,e+p); int l=1,r=p-1; while(l&lt;=r){ int md=(l+r)/2; int ret=djk(e[md]); if(ret&lt;k+1) r=md-1; else l=md+1; } printf(\"%d\\n\",e[r]); }} 通过上面的两条例题可以看出，最小化第 K 大值，是通过二分查找第 K 值 + 贪心 来实现的，二分查找第 K 值 中我们通过计算小于等于 x 的个数来判断 x 是在第 K 值的左边还是右边，而这里则使用最优的方案来计算小于等于 x 的个数，因此最后得出的第 K 值也是最优的。 其他折半舍去我们在判断一条题目是否可以使用二分的时候，最常用的一个方法就是判断其是否具有单调性，但其实只要能保证每次迭代的区间一定存在解，那么通过区间收敛就一定能获取解，单调性能比较容易看出并且实现这一点，但并不代表只有单调性才能使用二分。 例题：leetcode 852. 山脉数组的峰顶索引 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i。0&lt;i&lt;arr.length-1; 思路分析：如果区间 [l,r] 存在顶点，那么对于区间的 x， 如果有 arr[x+1]&gt;arr[x]，那么顶点一定在 [x+1,r]，反过来如果 arr[x]&gt;arr[x+1]，那么顶点一定在 [l,x]。 123456789101112class Solution { public int peakIndexInMountainArray(int[] arr) { int n=arr.length; int l=0, r=n-1; while(l&lt;r){ int md=(l+r)/2; if(arr[md+1]&gt;arr[md]) l=md+1; else r=md; } return l; }} 例题：Uva 1607 与非门电路 参考思路： 因为 n 个输入接收同一个 x，因此整个电路的功能无非就是 4 种：常数 0；常数 1；x，非 x。 我们可以先把所有的 x 全部设置为 0，再设置为 1，如果两者输出一致，那说明结果是常数，那么可以把所有的输入全部设置成 0，或者全部设置成 1。 如果输出不同，那么我们可以只需要讨论其中一种，因为它们逻辑是一样的。我们设 x=0时候，输出 0；x=1 时候，输出 1。现在我们把第一个输入改成 1，其他还是 0，如果输出是 1，那么就得到一个解 x00...00；如果输出还是 0 ，再把第二个也改成 1，如果输出 1，则又找到一个解 1x00...0，如果还是 0，再继续尝试11100...00，如此等等。由于全为 1 的时候，则一定会输出 1，这表示一定存在解。那为什么不直接使用 111...1x 呢？ 因为虽然全为 1 时输出一定为 1，但是 11...10 输出不一定为0，也有可能为 1，那么 111...1x 输出就变成了常数。 我们设输入为个时的输出那么如果存在 f(i)=0 和f(i+1)=1 ，则 i 和 i+1 就是我们要找的临界点，题目中可能会存在多个这样的临界点，但是我们只需要找到其中一个即可。我们设区间[l,r]满足f(l)=0 和 f(r)=1，那么如果区间中的 i 有 f(i)=0，那么区间可以缩小为[i,r]，反之如果f(i)=1，那么区间可以缩小为[l,i]，最终收敛为 (i,i+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100010;const int M=200010;struct gate{ int a,b,o;}gates[M];int n,m;int calc(int cnt){ for(int i=1;i&lt;=m;++i){ int a=gates[i].a; int b=gates[i].b; int ia=a&lt;0?(-a&lt;=cnt):gates[a].o; int ib=b&lt;0?(-b&lt;=cnt):gates[b].o; gates[i].o=~(ia&amp;ib); gates[i].o&amp;=1; } return gates[m].o;}// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif int T; scanf(\"%d\",&amp;T); while(T--&gt;0){ scanf(\"%d %d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(\"%d %d\",&amp;gates[i].a,&amp;gates[i].b); } int u=calc(0); int v=calc(n); if(u==v){ for(int i=0;i&lt;n;++i) printf(\"%c\",'1'); printf(\"\\n\"); }else{ int l=0,r=n; while(l&lt;r){ int md=(l+r)/2; if(calc(md)==u) l=md+1; else r=md; } char ch; for(int i=1;i&lt;=n;++i){ ch=i&lt;r?'1':(i==r?'x':'0'); printf(\"%c\",ch); } printf(\"\\n\"); } } return 0;} 参考资料《算法竞赛入门经典-第 2 版》 《挑战程序设计竞赛》 《oi-wiki》 《leetcode 网站》","link":"/blog/2024/02/04/binary_search/"},{"title":"贪心","text":"区间问题区间调度问题这种问题常常出现再工作或者会议安排上，其实就是求不相交区间数最大。 例题：参与尽量多的工作​ 有 n 项工作，每项工作分别再时间 si 开始，在时间 ti结束，对于每项工作，你都可以选择参与与否，但是如果选择参与，就必须完成该项工作，并且该工作时间段内不能参与任何其他工作。你的目标是参与尽量多的工作，返回该最大值。 限制条件： 1&lt;=N&lt;=100000; 1&lt;=si&lt;=ti&lt;=1e9; 例子： 输入：n=5; s={1,2,4,6,8}; t={3,5,7,9,0} 输出：3 （选取 1、3、5） 参考思路： 一般我们容易想到下面几个思路： 优先选择最早开始的：很明显会错误，最早开始也可以最迟结束，这样只能选择一个工作 优先选择最早结束的：是正确的，优先做尽量早结束的 优先选择用时最少的：一个用时很短的工作 C，可以连接两个本不相交的工作 A、B，这样本来可以选择 2 个变成了只能选择一个 优先选择最少重叠的：反例如下，第二行中间任务的重叠数最少，但如果优先选择此任务，最多只能完成 3 项，而实际全部选择第三行的任务，可以完成 4 项。 ———————— ———————————— ———————————————— 123456789101112131415161718//区间调度问题typedef pair&lt;int,int&gt; pi;pi itv[MAX_N];int solve(int n, vector&lt;int&gt; s, vector&lt;int&gt; t){ for(int i=0;i&lt;n;++i){ itv[i].second=s[i]; itv[i].first=t[i];//结束时间作 first } sort(itv.begin(),itv.end()); int ans=0; for(int i=0,t=0;i&lt;n;++i){ if(itv[i].second&gt;t){ ans++; t=itv[i].first; } } return ans;} 区间覆盖问题数轴上有 n 个闭区间 [ai,bi]，选择尽量少的区间，覆盖一条指定线段 [s,t]。突破口仍然是区间包含和区间排序，不过需要一次预处理。 每个区间在 [s,t] 外面的部分都应该切掉，因为它们是多余的。 预处理后，在相互包含的情况下，小区间显然是不应该考虑的。 把各个区间按照 ai 从小到大排序，如果第一个区间的起点不是 s，那么无解；否则选择起点为 s 的区间里面最长的一个，更新 s 为刚刚选择区间的 bi。 重复第一步，直到 s&gt;=t，或者区间已经被用完。 例题：leetcode 1024 视频拼接​ 你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。甚至可以对这些片段自由地再剪辑：例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。 123456789101112131415161718192021222324252627class Solution { typedef pair&lt;int,int&gt; pi;public: int videoStitching(vector&lt;vector&lt;int&gt;&gt;&amp; clips, int time) { vector&lt;pi&gt; ps; for(vector&lt;int&gt; c : clips){ ps.push_back({max(0,c[0]),min(time,c[1])}); } int n=ps.size(); //区间按照坐标开始时间从小到达排序 sort(ps.begin(),ps.end()); int ans=0,pre=0; //判断条件别漏了 pre &lt; time for(int i=0;i&lt;n&amp;&amp;pre&lt;time;++i){ //如果没有区间能覆盖当前的最左边，则返回-1 if(ps[i].first&gt;pre) return -1; int j=i; int t=ps[i].second; //所有能覆盖最左边的区间中选择最长的一个 while(i+1&lt;n&amp;&amp;ps[i+1].first&lt;=pre) t=max(t,ps[++i].second); pre=t;// 更新需要覆盖的最左边时间 ans++; } return pre &gt;=time ? ans : -1; }}; 区间问题（尤其覆盖问题）一定要注意： 区间的边界是否可以交接，要小心处理 s[i].end 和 s[i+1].start。 区间覆盖要记得 [s,t] 是否已经覆盖完，多余的区间要舍弃。 区间覆盖要记得区间是否已经使用完，最后要判断当前覆盖的最大值是否 &gt;= t。 45. 跳跃游戏 II 区间选点问题数轴上有 n 个闭区间 [ai,bi]。取尽量少的点，使得覆盖每个区间内至少有一个点。 和上面一样先考虑区间包含的情况，如果小区间被满足了，大区间一定被满足，所以在相互包含的情况下，大区间不应该考虑。 先按照 b 从小到大排序（b 相同 a 从大到小排序）。 取第一个区间的最后一个点，然后 ai 小于等于该点的区间都被跳过 ，直到 ai 大于刚刚选取的点，重复上一步。 例题：leetcode 452. 用最少数量的箭引爆气球​ 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart和 xend之间的气球。你不知道气球的确切y坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进，返回引爆所有气球所必须射出的 最小 弓箭数 。 1234567891011121314151617181920class Solution {public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { sort(points.begin(),points.end(), [](const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b){ // 按照 end 从小到大排序，如果 end 相同，start 大的排前面 //这样区间包含的时候小区间一定排在前面 return a[1]==b[1]?a[0]&gt;b[0]:a[1]&lt;b[1]; }); int n=points.size(); int ans=1,t=points[0][1]; for(int i=1;i&lt;n;++i){ if(points[i][0]&gt;t){ ans++; t=points[i][1]; } } return ans; }}; 区间最大重叠数问题我个人觉得这个应该不算贪心问题，更像一个单纯的模拟题，但是有时候我容易把它跟上面几个区间问题搞混了，因此在这里也记录一下。该问题就是求整个区间内最大的重叠数，打个比方就是一个大盘子里面放了好多饼，这些饼会相互部分重叠，也可能不重叠，求最厚的地方是多少。 例题：leetcode 253 会议室 II给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量。 思路分析：最早开始的会议肯定需要 1 个会议室，如果第 2 早开始的会议在前 1 个会议结束前开始，那么会议室 +1，否则使用空闲的。那么后面每个会议开始的时候都可以查看前面是否有空闲的会议室。我们可以使用计数来模拟上面的行为，我们把所有开始和结束的时间排序，碰到开始时间会议室 +1，碰到结束时间会议室 -1（这和后面开始的 +1 抵消，相当于使用空闲）。计数过程中的最大值，就是所需的最少会议室。也可以使用小根堆来模拟，那样模拟行为会更加明显。 12345678910111213141516171819class Solution { typedef pair&lt;int,int&gt; pi;public: int minMeetingRooms(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;pi&gt; times; for(vector&lt;int&gt;&amp; t : intervals){ times.push_back({t[0],1});// 1 表示开始 times.push_back({t[1],0});//如果某个结束时间和开始相同，结束排前面。 } sort(times.begin(),times.end()); int ans=0,cnt=0; for(auto &amp;t : times){ if(t.second) cnt++; else cnt--; ans=max(ans,cnt); } return ans; }}; 其他例题例题：POJ 3069 Saruman’s Army​ 直线上有 n 个点，坐标为 xi，选择若干个点添加标记，每个标记的点的覆盖范围是 R，要求所有点都能被标记点覆盖。求满足上述条件情况下，选择尽量少的点添加标记。 思路分析：我们从最左边的点开始考虑，这个点向右距离为 R 的范围内必须要有点（包括它自身）带有标记。哪给那个点带标记比较好呢？从贪心的角度考虑，最右的点是最好。因此我们从左边开始，选择其右边 R 范围内最远的点作为标记点，然把标记点右边距离其大于 R 的第一个点，作为新的最左边的点，依次类推。 1234567891011121314151617181920212223242526272829303132# include&lt;cstdio&gt;# include&lt;string&gt;# include&lt;algorithm&gt;using namespace std;int r,n,x[1010];// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif while(true){ scanf(\"%d %d\",&amp;r,&amp;n); if(r==-1&amp;&amp;n==-1) break; for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;x[i]); sort(x,x+n); int ans=0; for(int i=0;i&lt;n;++i){ int s=x[i]; int j=i; while(j+1&lt;n&amp;&amp;s+r&gt;=x[j+1]) ++j; int t=x[j]; while(j+1&lt;n&amp;&amp;t+r&gt;=x[j+1]) ++j; i=j; ans++; } printf(\"%d\\n\",ans); } return 0;} 字典序问题例题：note “POJ 3617 Best Cow Line​ 给定一个长度为 N 的字符串 S，要构造一个长度同样为 N 的字符 T，T 初始为空，你可以反复进行以下任意操作： 从 S 的头部删除一个字符，放到 T 的尾部。 从 S 的尾部删除一个字符，放到 T 的尾部 目标：T 字典序尽量小。 限制：1&lt;=N&lt;=1000 思路分析：从字典序的性质来看，无论 T 的末尾有多大，只要前面够小就行，因此我们可以使用下面的贪心算法：我们不断从 S 的开始和末尾取较小的一个。如果它们相等呢？因为我们贪心地想尽量早用到较小的字母，所以我们需要比较下一个，如果还相等，则下下一个，直到有一边较小的，那么就取较小的那一边的第一个。 因此我们可以这样设计算法： 我们可以把 S 反转后得到一个新的字符串 S’。 比较 S 和 S’ 的大小，如果 S 较小，则删除 S 的第一个字母添加到 T 的末尾；反之，则删除 S’ 的第一个字母添加到 T 的末尾。 依次类推直到 T 的长度等于原来字符串的长度。 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;const int MAX_N=2010;int N;char s[MAX_N];// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d\",&amp;N); for(int i =0;i&lt;N;++i){ scanf(\" %c\",&amp;s[i]); } int a=0; int b=N-1; int cnt=0; while(a&lt;=b){ bool left=true; for(int i=0;i+a&lt;=b-i;++i){ if(s[a+i]==s[b-i]) continue; left=s[a+i]&lt;s[b-i]; break; } if(left) putchar(s[a++]); else putchar(s[b--]); if(++cnt==80){ putchar('\\n'); cnt=0; } } if(cnt&lt;80) putchar('\\n'); return 0;} 哈夫曼编码问题哈夫曼编码的两个关键： 前缀码树：每个编码都是叶子路径编码，只有叶子才是最终的编码。 总价值最小的前缀码树：价值最小的两个节点最为兄弟节点，并且是深度最大的节点。 例题：POJ 3253 Fence Repair​ 有一块木板要切割成 块，每块的长度为 ,木板的初始长度为恰好是 的总和。每次切割的开销是这块木板的长度，求最小的切割开销。​ 例如长度为 21 木板需要切割成 5，8，8，则先把 21 切割成 8 和 13，开销是 21，再把 13 切割成 5 和 8，开销是 13，因此总开销是 34。 思路分析：把切割的过程看成一颗二叉树，根节点就是初始木板，需要最终切割的木板就是叶子，每次切割的开销为当前节点的长度，因此总的开销就是各个叶子节点木板的长度*其深度的和，因此我们就是要找一个让上面和最小的树，这不就和哈夫曼编码如何构造一颗最优编码树一样么？ 1234567891011121314151617181920212223242526272829303132333435363738394041# include&lt;cstdio&gt;# include&lt;string&gt;using namespace std;typedef long long LL;const int N=20010;int n,len[N];LL solve(){ LL ans=0; while(n&gt;1){ int mi1=0,mi2=1; if(len[mi1]&gt;len[mi2]) swap(mi1,mi2); for(int i=2;i&lt;n;++i){ if(len[i]&lt;=len[mi1]){ mi2=mi1; mi1=i; }else if(len[i]&lt;len[mi2]) mi2=i; } int t=len[mi1] + len[mi2]; ans+=t; if(mi1==n-1) swap(mi1,mi2); len[mi1]=t; len[mi2]=len[n-1]; --n; } return ans;}// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;++i) scanf(\"%d\",&amp;len[i]); LL ans=solve(); printf(\"%lld\\n\",ans); return 0;} 邻项交换法例题：POJ 3045 Cow Acrobats​ N 头牛叠罗汉，每头牛都有一个体重值 wi 和一个理论值 si，一头牛叠罗汉时候承受的风险等于其上面所有牛的体重之和（不包括自己）减去自身的力量值。给出每头牛的 wi 和 si，求如何安排叠罗汉的顺序，让所有牛中最大的风险系数最小。 思路分析：我们假设存在两头相邻的牛 和 ，这两头牛是否交换顺序不会影响它们上面和它们下面的牛的风险系数，它们只会影响它们本身。设 T 是它们上面所有牛的重量，它们不交换顺序和交换顺序的最大风险系数分别是是： 和 我们把 T 去掉就有： 和 假如是 i 排在前面更优，那么前面的公式就会更小，因此我们可以根据这个来排序，然后上到下计算每头牛的风险系数，最大值就是答案。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt; #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;using namespace std;const int N=50010;int n;struct cow{ int s,w;}cows[N];//排序对比int cmp (const cow &amp;a, const cow&amp; b){ return max(a.w-b.s,-a.s) &lt; max(b.w-a.s,-b.s);}//贪心 邻项交换法// #define LOCALint main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;++i){ scanf(\"%d %d\",&amp;cows[i].w,&amp;cows[i].s); } sort(cows,cows+n,cmp); int ans=-1e9,sw=0; for(int i=0;i&lt;n;++i){ int risk=sw-cows[i].s; sw+=cows[i].w; ans=max(ans,risk); } printf(\"%d\\n\",ans); return 0;} P1080 NOIP2012 国王游戏 后悔法思路就是无论当前是否是最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍去掉这个选项，否则，正式接受。如此往复。 例题：leetcode 871 最低加油次数​ 汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。沿途有 n 个加油站， 表示第 i 个加油站距离出发点 x 英里，可以加 f 升汽油。汽车最初的油量是 startFuel，每行驶 1 英里消耗 1 升汽油，可以认为油箱的容量是无限的，求到达终点所需加油的最小次数，如果不能到达终点则返回 -1。??? note “思路分析”​ 由于是求最小的加油次数，因此先考虑不加油，如果能一直开到终点则答案为 0 ，反之如果我们在到达某个加油站前就已经用光了汽油，那么我们可以“后悔”没加油，从已经路过的加油站中选择加油量最大的加，如果还不够则继续选择次大的加，直到总油量能到达下一站。然后我们再按照前面的后悔法一直开，等到没油的时候再后悔。如此往复，直到终点。但是如果中间出现即使把前面路过的加油站的油全加了也无法到达下一站，则返回 -1。 其实这题也是区间覆盖问题，区间左边是加油站，右边是加油站 + 提供的油量，使用最小的区间覆盖开始到目的地。后悔法是一种处理问题的技巧，它有时会用来解决区间覆盖问题，但不是只解决此类问题。 12345678910111213141516171819202122class Solution { typedef long long LL;public: int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) { stations.push_back({target,0}); int n=stations.size(); LL s=startFuel; priority_queue&lt;int&gt; pq; int ans=0; for(int i=0;i&lt;n;++i){ while(s&lt;stations[i][0]&amp;&amp;pq.size()) { s+=pq.top(); pq.pop(); ans++; } if(s&lt;stations[i][0]) return -1; pq.push(stations[i][1]); } return ans; }}; USACO09OPEN 工作调度 Work Scheduling P1209 [USACO1.3]修理牛棚 Barn Repair leetcode 630. 课程表 III 参考资料《算法竞赛入门经典 第2版》 《挑战程序设计竞赛》 《leetcode》 《oi-wiki》","link":"/blog/2024/02/05/greedy/"},{"title":"双指针(一)","text":"双指针是一种简单而又灵活的技巧和思想，单独使用可以轻松解决一些特定问题，和其他算法结合也能发挥多样的用处。双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。双指针本身的思想并不难，但是并不代表它很容易掌握，双指针的问题重点不在于你如何使用它，而是如何能“嗅到”该用它了。能用双指针解决的问题，数据往往都带有一些的特性质，比如单调性或者区间收敛，对这些数据的敏感度才是掌握双指针的关键，但不是每个人都是数学大神，对于这种情况“记录和总结”应该算是比较好的抢救方法了。 滑动窗口滑动窗口是双指针最经典的用法之一，通常对数组保存一对下标，然后根据实际情况交替推进两个端点直到得出答案。 例题：POJ 3061 subsequence给定长度为 n 的数列 a_0,a_1,a_2...a_n-1 以及整数 S，求出总和不少于 S 的连续子数组的长度的最小值，如果不存在则输出 0。解题思路：子区间求和，第一时间就是想到前缀和 $\\sum_{ij}=sum_j - sum_i$，因此对于每个 $\\sum_i$ 我们只需要求出满足 $\\sum_i+S$ 的最小的 $\\sum_j$ 就行了。由于 前缀和具有单调性质，因此可以考虑使用二分来解决，这样时间复杂度是 $\\O(nlogn)$。 我们先来考虑一下最暴力的解法： 123456789int ans=0;for(int i=0;i&lt;n;++i){ for(int j=i+1;j&lt;=n;++j){ if(sum[j]&gt;=sum[i]+S){ ans=max(ans,j-i); break; } }} 这是一个 $O(n^{2})$ 的方法，我们观察上面的代码可以发现 $S$ 是不变的，而 $sum[i]$ 是单调不减的，因此如果一个区间 $[j1,j2]$ 在 $i$ 的情况下不满足要求，那么在 $i + 1$ 下也肯定不满足要求，因此我们可考虑使用两个指针在一个 for 循环上来维护 $i$ 和 $j$ 的位置，因为对于被 $i$ 淘汰的 $j$ 来说，$i + 1$ 是不需要再回去遍历它们的。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n,s,a[N];int main(){ int T; for(scanf(&quot;%d&quot;,&amp;T);T&gt;0;--T){ scanf(&quot;%d %d&quot;,&amp;n,&amp;s); int ans=n+1; for(int i=0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;a[i]); for(int l=0,r=0,t=0;;){ while(r&lt;n&amp;&amp;t&lt;s) t+=a[r++]; if(t&lt;s)break; ans=min(ans,r-l); t-=a[l++]; } if(ans&gt;n) ans=0; printf(&quot;%d\\n&quot;,ans); }} 例题：leetcode 3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。思路分析：这是一种非常常见的滑动窗口面试题，通过统计区间的元素的个数来维持区间的某种性质，让其交替前进。 我们还是不妨先来考虑暴力枚举，我们枚举每一个结束字符的所有子区间，然后判断是否符合不包含重复字符的要求，然后取最大长度的那一个区间。 123456789for(int j=0;j&lt;s.size();++j){ memset(cnt,0,sizefo(cnt)); for(int i=j;i&gt;=0;--i){ if(cnt[s[i]]++==1) tot++;//如果当前字符之前已经存在第一个，那么重复字符个数 + 1 if(tot==0){//表示没有重复字符 ans=max(ans,j-i+1); } }} 上面算法的时间复杂度是 $O(n^{2})$，我们可以发现有很多重复的统计，对于字符串 “abcabcbb”，当我们统计以第一个 c 为结尾的子区间的时候，会统计abc 的个数，当我们统计以第二个a为结尾的子区间的时候，abc 的个数还会被重新统计，但是其实我们可以重复利用前面的统计。我们可以使用两个指针 i 和 j 来维护一个区间，让区间在每次迭代后都满足重复个数等于 0 条件即可。 123456789101112131415class Solution {public: int lengthOfLongestSubstring(string s) { vector&lt;int&gt; cnt(256,0); int l,r,ans=0,tot=0; for(l=0,r=0;r&lt;s.size();++r){ if(cnt[s[r]]++==1) tot++; while(tot){ if(--cnt[s[l++]]==1) tot--; } ans=max(ans,r-l+1); } return ans; }}; leetcode 567. 字符串的排列 leetcode 30. 串联所有单词的子串 例题：leetcode 220. 存在重复元素 III给你一个整数数组 $nums$ 和两个整数 $k$ 和 $t$ 。请你判断是否存在 两个不同下标 $i$ 和 $j$，使得 $abs(nums[i] - nums[j]) &lt;= t$ ，同时又满足 $abs(i - j) &lt;= k$。 思路分析： 这种类型的滑动窗口长度是固定，所以推进是比较简单，但是往往会结合一些数据结构，比如堆、单调队列或者有序集合等。典型问题是的动态查询每个区间的第 n 大值，或者是否存在满足条件的元素。 就这题而言，我们可以枚举每个 $nums[j]$，因此问题就变成了在下标区间 $[j-k,j]$ 范围内是否存在一个数 $x$，其满足 $nums[j]-t&lt;=x&lt;=nums[j]+t$，可以使用一个有序集合（比如平衡树）来维护当前窗口除 $nums[j]$ 以外的所有数，我们通过查找第一个大于等于 $nums[j]-t$ 的数 $x$，判断 $x$ 是否满足上面的条件即可。 1234567891011121314class Solution {public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) { set&lt;long long&gt; st; int n=nums.size(),l,r; for(l=0,r=0;r&lt;n;++r){ auto it=st.lower_bound((long long)nums[r]-t); if(it!=st.end()&amp;&amp;*it&lt;=(long long)nums[r]+t) return true; st.insert(nums[r]); if(r&gt;=k) st.erase(nums[l++]); } return false; }}; 例题：leetcode 480. 滑动窗口中位数给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数（如果 k 为偶数，中位数为中间两个数的平均值），并输出由它们组成的数组。 思路分析： 和上面的题目一样，都是长度是固定的滑动窗口问题。我们可以通过两个堆来维护第 k/2 大值，左边 [0,k/2) 为大顶堆，右边 [k/2,k] 为小顶堆，因此我们只需要通过两个堆的堆顶即可得到中位数。 首先初始化一个长度为 k 的窗口，并且获取第一个中位数。 窗口往右边滑动一个数，就把该数压入堆顶，如果右边的堆为空，或者该数比右边堆顶要大，则压入右边，否则左边。 窗口左边出一个数，如果该数大于等于右边堆顶，则从右边堆顶删除，否则从左边删除。 维护两边堆的个数，如果左边个数小于 k/2，则把右边的堆顶弹出压入左边，如果左边个数大于 k/2，则把左边的堆顶弹出压入右边。 获取中位数 循环第 2 - 5 步。 由于需要删除堆元素，因此需要自定义实现一个懒删除堆。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071typedef long long LL;class PQ { private: priority_queue&lt;LL&gt; pq; unordered_map&lt;LL,int&gt; delayed; int delCnt=0; private: void prune(){ while(pq.size()&amp;&amp;delayed.count(pq.top())){ int c=--delayed[pq.top()]; if(c==0) delayed.erase(pq.top()); pq.pop(); delCnt--; } } public: int size(){ return pq.size() - delCnt; } LL top(){ prune(); LL res=pq.top(); return res; } LL pop(){ LL res=top(); pq.pop(); return res; } void push(LL x){ pq.push(x); } void del(LL x){ delayed[x]++; delCnt++; }};class Solution {public: PQ L; //大顶堆 PQ R; //通过存入相反数来模拟小顶堆 double getMedian(int k){ if(k&amp;1) return -R.top(); return ((double)L.top()-R.top())/2; } vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int l,r,n=nums.size(); vector&lt;double&gt; ans(n-k+1,0); //初始化第一个长度为 k 的窗口 for(l=0,r=0;r&lt;k;++r) R.push(-(LL)nums[r]); for(int i=0;i&lt;k/2;++i) L.push(-R.pop()); int cur=0; ans[cur++]=getMedian(k); //不断向右滑动 for(;r&lt;n;++r,++l){ int a=nums[l], b=nums[r]; if(R.size()==0 ||b&gt;=-R.top()) R.push(-(LL)b); else L.push(b); if(a&gt;=-R.top()) R.del(-(LL)a); else L.del(a); while(L.size()&lt;k/2) L.push(-R.pop()); while(L.size()&gt;k/2) R.push(-L.pop()); ans[cur++]=getMedian(k); } return ans; }}; 例题：leetcode 424. 替换后的最长重复字符你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。在执行上述操作后，返回包含相同字母的最长子字符串的长度。 思路分析： 对于区间 $[l,r]$ 需要满足 $r-l+1-cnt&lt;=k$，其中 $cnt$ 是不需要改变的字母数量，由于 $k$ 是常量，因此 $cnt$ 越大，$r-l+1$ 的值也就可以越大。因此在遍历的过程中我们只需要关注最大的 $max(cnt)$ 就行。当 $r$ 向右移动变成 $r+1$后，如果 $max(cnt)$ 不变，那么区间会变为 $[l+1,r+1]$，如果 $max(cnt)$ 增大了，那一次只会增大 $1$，这时候区间变为 $[l,r+1]$，最后 $r$ 滑到最右边的时候，最后的区间长度一定等于最优的长度。 如果题目要求最长字串的内容，那么不能取最后的区间字串，需要取最大 cnt 的第一次出现的区间字串。 123456789101112class Solution {public: int characterReplacement(string s, int k) { vector&lt;int&gt; cnt(256,0); int l,r,mx=0,n=s.size(); for(l=0,r=0;r&lt;n;r++){ mx=max(mx,++cnt[s[r]]); // r 向右移动一个字符 if(r-l+1-mx&gt;k) --cnt[s[l++]];//如果 mx 没有改变 l++ } return r-l; }}; leetcode 2024. 考试的最大困扰度 例题：leetcode 992. K 个不同整数的子数组给定一个正整数数组 $nums$ 和一个整数 $k$ ，返回 $nums$ 中「好子数组」 的数目。如果 $nums$ 的某个子数组中不同整数的个数恰好为 $k$，则称 $nums$ 的这个子数组为 「好子数组 」。 参考思路： 我们可以枚举每一个子数组的最后一个元素，下标设为 $r$，同时设$cnt(l,r)$ 为子数组$[l,r]$的不同整数的数目，对于任意一个 $r$，如果存在一个区间 $[l1,l2]$ 满足 $cnt(l,r)==k,(l1&lt;=l&lt;=l2)$，那么一定有 $cnt(l,r) &gt;k,(l&lt; l1)$ 和 $cnt(l,r) &lt; k,(l&gt;l2)$，因此满足 r 的所有左端点都在区间 [l1,l2] 这连续区间内，同时 [l1,l2] 的所有点也都可以作为 r 的左端点。但是那样我们需要求出每个 r 的 [l1,l2]，时间复杂度是 $O(n^{2})$。 由于我们只需要求子数组的个数，所以我们可以维护两个区间 $[l1,r]$ 和 $[l2+1,r]$，那么对于右端点 $r$ 来说满足要求的左端点个数就是 $l2+1-l1$。$l1$ 是第一个满足 $cnt(l1,r)==k$ 的左端点，而 $l2+1$，是第一个满足 $cnt(l2+1,r) &lt; k$ 的左端点。 1234567891011121314151617181920class Solution {public: int subarraysWithKDistinct(vector&lt;int&gt;&amp; nums, int k) { int n=nums.size(); map&lt;int,int&gt; cnt1,cnt2; int l1=0,l2=0,r=0,t1=0,t2=0,ans=0,a=0; for(;r&lt;n;++r){ if(++cnt1[nums[r]]==1) t1++; if(++cnt2[nums[r]]==1) t2++; while(t1&gt;k) { if(--cnt1[nums[l1++]]==0) t1--; } while(t2&gt;k-1){ if(--cnt2[nums[l2++]]==0) t2--; } ans+=l2-l1; } return ans; }}; 例题：leetcode 167. 两数之和 II - 输入有序数组给你一个下标从 1 开始的非递减整数数组 numbers ，请你从数组中找出满足相加之和等于目标数 target 的两个数。你可以假设每个输入只对应一个答案。 1234567891011121314151617class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int i,j,n=numbers.size(); vector&lt;int&gt; ans; for(i=0,j=n-1;i&lt;j;){ if(numbers[i]+numbers[j]==target) { ans.push_back(i+1); ans.push_back(j+1); break; } if(i&lt;j&amp;&amp;numbers[i]+numbers[j]&gt;target) --j; if(i&lt;j&amp;&amp;numbers[i]+numbers[j]&lt;target) ++i; } return ans; }}; 例题：leetcode 11. 盛最多水的容器给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。 12345678910111213class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int n=height.size(); int ans=0; for(int i=0,j=n-1;i&lt;j;){ ans=max(ans,(j-i)*min(height[i],height[j])); if(height[i]&lt;height[j]) ++i; else --j; } return ans; }}; 参考资料《挑战程序设计竞赛》 《算法竞赛入门经典》 《leetcode》 [《OI-WIKI》](","link":"/blog/2024/02/05/algorithm/double_point/"},{"title":"动态规划","text":"背包问题01 背包01 背包本身是一个子集问题，有 n 个物品，每个物品都可以选择或者不选择，那这是一颗深度为 n 的二叉树，这是背包问题的暴力解法，穷举每一种组合，时间复杂度为 o(2^n)。 要注意背包问题的特点： 一般背包问题都是只有一个维度的限制，这里是背包的重量 W。 一般只求一个值，这里是价值 V。 1234567891011for(int i=0;i&lt;n;++i){ for(int j=w[i];j&lt;=W;++j){ dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]); }}//使用滚动数组优化for(int i=0;i&lt;n;++i){ for(int j=W;j&gt;=w[i];--j){//倒序是因为避免覆盖 dp[i-1][j] dp[j]=max(dp[j],dp[j-w[i]]+v[i]); }} 时间复杂度 O(NW)。 完全背包完全背包可以看作成 01 背包，我们可以把同种类型的没意见物品看作单独一个物品，这就是一个 01 背包。 1234567891011121314151617181920for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=W,++j){ for(int k=0;k*w[i]&lt;=j;++k){ dp[i][j]=max(dp[i][j],dp[i][j-k*w[i]]+k*v[i]); } }}//这样会存在重复的计算，比如 dp[i][j] 下选择 k 件物品，等同于 dp[i][j-w[i]] 选择 k-1 件物品。for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=W;++j){ dp[i][j]=d[i-1][j]; if(j&gt;=w[i]) dp[i][j]=max(dp[i][j],dp[i][j-w[i]] + v[i]); }}//使用滚动数组优化for(int i=0;i&lt;n;++i){ for(int j=w[i];j&lt;=W;++j){//顺序是因为需要使用 dp[i][j] 而不是 dp[i-1][j] dp[j]=max(dp[j],dp[j-w[i]]+v[i]); }} 多重部分和问题这个我觉得是多重背包的简单版本，它们的原始的推导公式几乎一样，但是因为求值比较简单，因为可以化简为类似完全背包的解法。 12345678910111213141516171819202122for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=K;++j){ for(int k=0;k*a[i]&lt;=j&amp;&amp;k&lt;=m[i];++k){ dp[i][j]|=dp[i-1][j-k*a[i]]; } }}//如果只是求 bool 结果的话，这样 dp 会有浪费，同样的复杂度可以存储更多的信息。//dp[i][j]: 表示使用第 i 种数字的时候，在和为 j 的情况下，最多可以剩余多少个该种数字。memset(dp,-1,sizeof(dp)); //memset 只可以填充 0 和 -1。for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;=K;++j){ if(dp[j]&gt;=0){ dp[j]=m[i];//如果前 i - 1 种数字能满足和 j，则最多可以剩余 m[i] 个。 }else if(j&lt;a[i]||dp[j-a[i]]&lt;0){ dp[j]=-1; }else{ dp[j]=dp[j-a[i]]-1; } }}return dp[n][K]&gt;=0; 计数DP划分数有 n 个完全相同的物品，将它们分成不超过 m 组，求划分方法数摸 M 的余数。限制条件： 1&lt;=m&lt;=n&lt;=1000 2&lt;=M&lt;=10000; 递推公式： dp[i][j]: 表示 j 的 i 划分。dp[i][j]=dp[i][j-i]+dp[i-1][j]; 123456789101112131415int n,m;int dp[MAX_M+1][MAX_N+1];int solve(){ dp[0][0]=1; for(int i=1;i&lt;=m;++i){ for(int j=0;j&lt;=n;++j){ if(j&gt;=i){ dp[i][j]=dp[i][j-i] + dp[i-1][j]; }else{ dp[i][j]=dp[i-1][j]; } } } return dp[m][n];} 多重集的组合数有 n 种不同类型的物品，第 i 种物品有 a[i] 个，不同种类的物品可以相互区分，但是同种类型的物品无法区分，从这些物品中恰好取 m 个，有多少种取法？求出方案数模 M 的余数。 限制条件 1&lt;=n&lt;=1000; 1&lt;=m&lt;=1000; 1&lt;=a[i]&lt;=1000; 1&lt;=M&lt;=10000; 分析： 和划分数不一样，这题目是求只拿一组的情况下有多少种方法。 ps: 如果当当 n 个不同的物品中取出 M 个，则单纯是一个组合问题， dp[i][j]: 表示前 i 种物品，恰好取 j 件一共有多少种取法。那么如果第 i 种物品我想拿 k 件，那么方案数是前 i-1种物品中取出 j-k 件的方案数，因此：右边展开后，变形 所以：这样就可以在时间复杂度 o(nm) 内解决问题 1234567891011121314151617181920int n, m;int a[MAX_N];int dp[MAX_N][MAX_M];int solve(){ //初始化，前 i 个物品只取 0 个都是只有一个方案。 for(int i=0;i&lt;=n;++i){ dp[i][0]=1; } for(int i=0;i&lt;n;++i){ for(int j=1;j&lt;=m;++j){ if(j-1-a[i]&gt;=0){ dp[i+1][j]=(dp[i+1][j-1] + dp[i][j] - dp[i][j-1-a[i]] + M) % M; }else{ dp[i+1][j]=(dp[i+1][j-1] + dp[i][j]) % M;//如果没有数量 a[i] 限制的话，是不是就是完全背包的公式。 } } } return dp[n][m];}","link":"/blog/2024/02/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/blog/categories/%E7%AE%97%E6%B3%95/"}],"pages":[]}