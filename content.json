{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/blog/2024/02/04/hello-world/"},{"title":"hexo-example","text":"","link":"/blog/2024/02/04/hexo-example/"}],"tags":[],"categories":[{"name":"编程类","slug":"编程类","link":"/blog/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"},{"name":"数学类","slug":"数学类","link":"/blog/categories/%E6%95%B0%E5%AD%A6%E7%B1%BB/"}],"pages":[{"title":"二分","text":"二分查找值这是二分搜索最简单的用法，在有序的数组中查找某个值是否存在，或者最接近某个值的值。 C++ STL 实现了二分查找值的算法，可以直接使用 123456789101112131415161718192021222324//返回第一个大于或者等于 x 的下标，如果不存在则返回 nint i=lower_bound(a,a+n,x) - a;//返回第一个大于或者等于 x 的迭代器，如果不存在则返回尾迭代器。auto it=lower_bound(a.begin(),a.end(),x);//返回第一个大于 x 的下标，如果不存在则返回 nint i=upper_bound(a,a+n,x) - a;//返回第一个大于或者等于 x 的迭代器，如果不存在则返回尾迭代器。auto it=upper_bound(a.begin(),a.end(),x);//注意： 如果是 set 和 map 这种关联式容器，使用上面的两个方法的时间复杂度是 O(n)，需要使用容器自带的方法，时间复杂度为 O(logn)。auto it=s.lower_bound(x);//快速找出有序数组 a 中 x 的数量。int cnt=upper_bound(a,a+n,x) - lower_bound(a,a+n,x);int cnt=upper_bound(a.begin(),a.end(),x) - lower_bound(a.begin(),a.end(),x);//有序数组 a 中 小于 x 的数量int cnt=lower_bound(a,a+n,x) - a;int cnt=lower_bound(a.begin(),a.end(),x) - a.begin();//有序数组 a 中 小于等于 x 的数量int cnt=upper_bound(a,a+n,x) - a;int cnt=upper_bound(a.begin(),a.end(),x) - a.begin(); 假定判断假定判断就是先假定一个解并且判断是否可行，在二分中使用也是非常的频繁，例如求解最大化或者最小化问题。 例题：POJ 1064 Cable master 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;const int N=10010;int n,k;double L[N];int calc(double len){ int res=0; for(int i=0;i&lt;n;++i) res+=(int)(L[i]/len); return res;}//标签：二分 求最大值 实数二分// #define LOCALint main(){ #ifdef LOCAL freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;++i){ scanf(&quot;%lf&quot;,&amp;L[i]); } double l=0,r=100010; //100 次循环精度可以达到 10^-30，基本上是没有问题的 for(int i=0;i&lt;100;i++){ double md=(l+r)/2; if(calc(md)&gt;=k) l=md; else r=md; } printf(&quot;%.2f\\n&quot;,floor(r*100)/100); return 0;} 最大化最小值例题：POJ 2456 Aggressive cows 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt; #include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N=100010;int n, c,x[N];bool check(int k,int cnt){ cnt--; for(int i=1,j=0;i&lt;n&amp;&amp;cnt;i++){ if(x[i]-x[j]&gt;=k){ j=i; cnt--; } } return cnt==0;}//标签：二分 最大值最小// #define LOCALint main(){ #ifdef LOCAL freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif scanf(&quot;%d %d&quot;,&amp;n,&amp;c); for(int i=0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;x[i]); sort(x,x+n); int l=0,r=x[n-1]-x[0]; while(l&lt;=r){ int md=l+(r-l)/2; if(check(md,c)) l=md+1; else r=md-1; } printf(&quot;%d\\n&quot;,r);} 最大化最小值或者最小化最大值 经常也会带有一定的贪心算法在里面，通常借助排序或者优先队列来建立判断条件。 最大化平均值例题：有 n 个物品的重量和价值分别是 wi 和 vi。从中选出 k 个物品使得单位重量的价值最大。 限制条件： 1&lt;=k&lt;=n&lt;1000；1&lt;=wi,vi&lt;=1000000 样例： 输入：n=3；k=2；(w,v)={(2,2),(5,3),(2,1)} 输出：0.75 (选择 0 号和 2 号物品，(2+1)/(2+2)=0.75) 解题思路： 一般最先想到的方法是按照单位价值进行排序，从大到小贪心地进行选择，但是这种方法对于上面的例子的结果是 0.714，所以这种方式不可行。 我们可以使用二分解决这个问题，假定判断条件： $$C(x)=可以通过选择使得单位价值不小于 x$$那么原问题就变成了求满足 C(x) 的最大的 x。假设我们选择的集合是 s，因此它们的单位价值是： $$\\sum_{k \\in s} vi \\div \\sum_{k \\in s} wi \\geq x$$ 把上面不等式进行变形： $$\\sum_{k \\in s} (vi-x \\times wi) \\geq 0$$ 因此可以对$$(vi-x \\times wi)$$的值进行排序，然后贪心地进行选取： $$C(x)=(vi-x \\times wi)从大到小前 k 个和不小于0$$ 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;using namespace std;const int MAX_N = 10010;int n, k;int w[MAX_N], v[MAX_N];double y[MAX_N], INF;//判断是否满足条件bool C(double x){ for (int i = 0; i &lt; n; ++i){ y[i] = v[i] - w[i] * x; } sort(y, y + n); //计算最大的 K 个 yi 的和 double sum = 0; for (int i = 0; i &lt; k; ++i){ sum += y[n - 1 - i]; } return sum &gt;= 0;}void solve(){ double l = 0, r = INF; for (int i = 0; i &lt; 100; ++i){ double md = (l + r) / 2; if (C(md)) l = md; else r = md; } printf(&quot;%.2f\\n&quot;, l); 查找第 K 个值如果是有序序列（比如：数组），我们可以直接读取第 k 个值，但是有时候我们并不能高效地定位到第 k 个值，或者第 K 个值是动态的，比如二维矩阵、动态查询等，这时候我们可以尝试考虑二分查找。 利用二分来查找第 k 个值，一般基于这么一个判断：设定一个值 x，如果 x 小于第 k 个值，那么小于等于 x 的个数一定小于 k；反过来如果 x 大于等于第 k 个值，那么小于等于 x 的个数一定不小于 k，这其实就是一个假定判断，因此这种方法的核心就是计数。 ps ：在有序的序列中，upper_bound 和 lower_bound 能非常方便的计算小于某个值的个数。 例题：leetcode 668. 乘法表中第k小的数 几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？乘法表是大小为 m x n 的一个整数矩阵，其中 mat[i][j] == i * j（下标从 1 开始）。给你三个整数 m、n 和 k，请你在大小为 m x n 的乘法表中，找出并返回第 k 小的数字。 参考思路：就是使用上面的判断方法来进行二分，关键是计数,这里很简单，因为$$mat[i][j]=i \\times j$$因此每一行小于等于 x 的个数就是$$min(n,x/i)$$m x n 的矩阵可以在 O(m) 的时间复杂度内进行每次的计数。 12345678910111213141516171819202122class Solution {public: int findKthNumber(int m, int n, int k) { if(m&gt;n) swap(m,n); int l=1; int r=9e8; while(l&lt;=r){ int mid=l + (r-l)/2; if(calc(m,n,mid)&lt;k) l=mid+1; else r=mid-1; } return l; } int calc(int m, int n,int mid){ int res=0; for(int i=1;i&lt;=m;++i){ res+=n*i&lt;=mid?n:mid/i; } return res; }}; 最小（大）化第 K 值例题：POJ 2010 Moo University - Financial Aid“ 农场新建了一所奶牛大学，想从一共 $C$ 头牛中招收 $N$ 头牛作为学生（$N &lt;= C$，而且 $N$ 是奇数），每头牛都有一个如下前的考试分数 $ci$ 和一个需要补助的学费 $fi$。但是目前大学总的补助经费只有 $F$，因此不能随意招收任意的奶牛。现在你是招生办主任，你要在不超过补助经费 $F$ 的情况下，从 $C$ 头牛中选 $N$ 头录取，并且分数中位数最大。 思路分析： 由于N是奇数，因此就是让第 N/2 + 1 高的分数最大，怎么办？我们可以先考虑最暴力的解法，求出所有的符合条件的 N头牛的不同组合，然后对比这些组合中第 N/2 + 1 高的分数，那个最大。但是组合数太大了，而且如果我们把每个组合的分数排序然后取第 N/2 + 1 个分数，那总的时间复杂度需要$$\\displaystyle \\binom{C}{N} \\times O(NlogN)$$​ 如果我们像上面那样使用二分来取第 K 大值呢，好像时间复杂度还是 O(NlogN)，但是它可以使用一些贪心算法，我们没必要比对每个组合。我们回忆一下上面求第 K 大值的方法，我们根据当前小于等于 x 的个数 count 来决定 x 是该增大还是减少，假如 count 小于 K，那么 x 就可以增大。那么回到当前，如果这些组合里面至少存在一个组合的 count 比 K 小，那么 x 就可以增大了，换句话说只要存在有 count 比 K 小，x 就可以增大，那么我们是不是可以只和最小的 count 比就行了。那么我们如何让比 x 小的个数尽量少呢？在经费不超过 F 的情况下，尽量选分数比 x 大就行。但是需要额外先判断是否存在解，只有一定存在解才进入二分的逻辑，可以避免特殊边界的判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAX_C=100010;int N,C,F,L[MAX_C],R[MAX_C];struct cow{ int c,f;}cows[MAX_C];int cmp(const cow&amp; a, const cow&amp; b){ return a.c&lt;b.c;}// 标签：二分 最小化第 K 大的值 int calc(int x){ for(int i=0;i&lt;C;++i){ L[i]=cows[i].f; } int i,j,l,r; for(i=0,l=0,r=0;i&lt;C;++i){ if(cows[i].c&lt;=x) L[l++]=cows[i].f; else R[r++]=cows[i].f; } int res=0; sort(L,L+l);//分数小于等于 x 的奶牛的补助放到一个数组，称为左边 sort(R,R+r);//分数比 x 大的奶牛的补助放到一个数组，称为右边 LL s=0,cnt=0; for(i=0;cnt&lt;N&amp;&amp;i&lt;r;++i) s+=R[i],++cnt;//优先右边选，并且从小往大选，这样能选尽量多。 j=i; for(i=0;i&lt;l&amp;&amp;cnt&lt;N;++i) s+=L[i],++cnt;//如果右边的奶牛总算不够 N 头，从左边补够N头。 for(;i&lt;l&amp;&amp;s&gt;F;++i) s+=L[i]-R[--j];//如果总的补助大于 F，那么把右边最大替换掉，再用左边较小的替换。 res=i;//左边一共选择了多少头，就是有多个分数小于等于 x。 return res;}// #define LOCALint main(){ #ifdef LOCAL freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif scanf(&quot;%d %d %d&quot;,&amp;N,&amp;C,&amp;F); for(int i=0;i&lt;C;++i){ scanf(&quot;%d %d&quot;,&amp;cows[i].c,&amp;cows[i].f); L[i]=cows[i].f; } sort(L,L+C); LL s=0; int ans=-1; for(int i=0;i&lt;N;++i) s+=L[i]; //判断是否无解，如果无解不需要二分 if(s&lt;=F){ sort(cows,cows+C,cmp); int l=0,r=C-1,k=N/2+1; while(l&lt;=r){ int md=(l+r)/2; if(calc(cows[md].c)&lt;k) l=md+1; else r=md-1; } ans=cows[l].c; } printf(&quot;%d\\n&quot;,ans); return 0;} 例题：POJ 3662 Telephone Lines FJ 想在电话公司和自己的农场之间建立电话线路，它们之间有 n 根电线杆，1 和 n 号电线杆分别在电话公司和农场内，这些电线杆之间有的可以相互连接(a,b,l 表示a 和 b 连接的费用是 l)，有的不行。电话公司愿意支付 k 根最贵的电话线，剩下的电话线中最贵的一根的费用就是 FJ 需要支付的最终费用。求 FJ 可以建立电话线路需要的最小费用。 解题思路：这是一张无向图，如果 1 和 n 之间非连通，则返回 -1，如果连通需要的最少边数小于等于 k 则费用是0，如果边数大于 k ，则第 k+1 贵的电线就是 FJ 要支付的费用，因此问题就是最小化第 k+1大的值。 连通性和连通的最少边数可以使用 BFS 求出，这个非常简单，问题是如何才能最小化第 K+1 大的值。不妨先想办法找出每条路径第 k+1 大的值，然后取它们中的最小值，总体上的思路和上面 POJ 2010 类似，使用二分 + 贪心。我们依然使用 x 来判断，如果大于等于 x 的边数 count 少于 k+1，那么说明 x 还可以更小，因此我们只需要和最小的 count 比就行。我们设大于等于 x 的边权为 1，其他为 0，那么最小的 count 就是最短路径，可以使用 dijkstra 算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int P=20100; // 要记得向前星无向边的容量是边数的两倍const int N=1010;int n,p,k,d[N],e[P];priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt;&gt; pq; //小根堆struct Edge{ int to, w,next;}edges[P];int id,head[P];void add(int u, int v, int w){ edges[++id].to=v; edges[id].next=head[u]; edges[id].w=w; head[u]=id;}int djk(int x){ memset(d,-1,sizeof(d)); while(pq.size()) pq.pop(); //这里一定要注意清空队列 d[1]=0; pq.push(make_pair(0,1)); while(pq.size()){ pi t=pq.top(); pq.pop(); int w=t.first, u=t.second; if(u==n) break; if(d[u]!=-1&amp;&amp;d[u]&lt;w) continue; for(int i=head[u];i;i=edges[i].next){ int v=edges[i].to; if(d[v]==-1||(d[v]&gt;d[u]+(edges[i].w&gt;=x))){ d[v]=d[u] + (edges[i].w&gt;=x); pq.push(make_pair(d[v],v)); } } } return d[n];}//#define LOCALint main(){ #ifdef LOCAL freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif scanf(&quot;%d %d %d&quot;,&amp;n,&amp;p,&amp;k); int u,v,w; for(int i=0;i&lt;p;++i){ scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); e[i]=w; } int mik=djk(0); if(mik&lt;0) printf(&quot;%d\\n&quot;,-1); else if(mik&lt;=k) printf(&quot;%d\\n&quot;,0); else { sort(e,e+p); int l=1,r=p-1; while(l&lt;=r){ int md=(l+r)/2; int ret=djk(e[md]); if(ret&lt;k+1) r=md-1; else l=md+1; } printf(&quot;%d\\n&quot;,e[r]); }} 通过上面的两条例题可以看出，最小化第 K 大值，是通过二分查找第 K 值 + 贪心 来实现的，二分查找第 K 值 中我们通过计算小于等于 x 的个数来判断 x 是在第 K 值的左边还是右边，而这里则使用最优的方案来计算小于等于 x 的个数，因此最后得出的第 K 值也是最优的。 其他折半舍去我们在判断一条题目是否可以使用二分的时候，最常用的一个方法就是判断其是否具有单调性，但其实只要能保证每次迭代的区间一定存在解，那么通过区间收敛就一定能获取解，单调性能比较容易看出并且实现这一点，但并不代表只有单调性才能使用二分。 例题：leetcode 852. 山脉数组的峰顶索引 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i。0&lt;i&lt;arr.length-1; 思路分析：如果区间 [l,r] 存在顶点，那么对于区间的 x， 如果有 arr[x+1]&gt;arr[x]，那么顶点一定在 [x+1,r]，反过来如果 arr[x]&gt;arr[x+1]，那么顶点一定在 [l,x]。 123456789101112class Solution { public int peakIndexInMountainArray(int[] arr) { int n=arr.length; int l=0, r=n-1; while(l&lt;r){ int md=(l+r)/2; if(arr[md+1]&gt;arr[md]) l=md+1; else r=md; } return l; }} 例题：Uva 1607 与非门电路 参考思路： 因为 n 个输入接收同一个 x，因此整个电路的功能无非就是 4 种：常数 0；常数 1；x，非 x。 我们可以先把所有的 x 全部设置为 0，再设置为 1，如果两者输出一致，那说明结果是常数，那么可以把所有的输入全部设置成 0，或者全部设置成 1。 如果输出不同，那么我们可以只需要讨论其中一种，因为它们逻辑是一样的。我们设 x=0时候，输出 0；x=1 时候，输出 1。现在我们把第一个输入改成 1，其他还是 0，如果输出是 1，那么就得到一个解 x00...00；如果输出还是 0 ，再把第二个也改成 1，如果输出 1，则又找到一个解 1x00...0，如果还是 0，再继续尝试11100...00，如此等等。由于全为 1 的时候，则一定会输出 1，这表示一定存在解。那为什么不直接使用 111...1x 呢？ 因为虽然全为 1 时输出一定为 1，但是 11...10 输出不一定为0，也有可能为 1，那么 111...1x 输出就变成了常数。 我们设$$f(i)=输入为 i 个 1 时的输出$$那么如果存在 f(i)=0 和f(i+1)=1 ，则 i 和 i+1 就是我们要找的临界点，题目中可能会存在多个这样的临界点，但是我们只需要找到其中一个即可。我们设区间[l,r]满足f(l)=0 和 f(r)=1，那么如果区间中的 i 有 f(i)=0，那么区间可以缩小为[i,r]，反之如果f(i)=1，那么区间可以缩小为[l,i]，最终收敛为 (i,i+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100010;const int M=200010;struct gate{ int a,b,o;}gates[M];int n,m;int calc(int cnt){ for(int i=1;i&lt;=m;++i){ int a=gates[i].a; int b=gates[i].b; int ia=a&lt;0?(-a&lt;=cnt):gates[a].o; int ib=b&lt;0?(-b&lt;=cnt):gates[b].o; gates[i].o=~(ia&amp;ib); gates[i].o&amp;=1; } return gates[m].o;}// #define LOCALint main(){ #ifdef LOCAL freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0){ scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(&quot;%d %d&quot;,&amp;gates[i].a,&amp;gates[i].b); } int u=calc(0); int v=calc(n); if(u==v){ for(int i=0;i&lt;n;++i) printf(&quot;%c&quot;,'1'); printf(&quot;\\n&quot;); }else{ int l=0,r=n; while(l&lt;r){ int md=(l+r)/2; if(calc(md)==u) l=md+1; else r=md; } char ch; for(int i=1;i&lt;=n;++i){ ch=i&lt;r?'1':(i==r?'x':'0'); printf(&quot;%c&quot;,ch); } printf(&quot;\\n&quot;); } } return 0;} 参考资料《算法竞赛入门经典-第 2 版》 《挑战程序设计竞赛》 《oi-wiki》 《leetcode 网站》","link":"/blog/algorithm/binary_search.html"}]}